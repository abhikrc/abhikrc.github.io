Title: A Type System for Proving Correctness of Compiler Optimizations

Authors: Yutaka and Hiroyuki


1 - How do you classify this paper? 3

   3: Strong Accept

   2: Weak Accept

   1: Weak Reject

   0: Strong Reject



2 - What is your overall expertise concerning the subject areas of this
paper? X

   X: I am an expert.
   Y: I am knowledgeable in the area, though not an expert
   Z: I am not an expert. My evaluation is that of an informed outsider.

3 - Main Contributions of the paper
The paper presents a type system for proving correctness of compiler
optimizations. Variables are provided assignment types. Loops are dealt
with by recursive types. Type equivalence is checked by showing
equivalence of regular trees. A proof of soundness of the type system is
provided

4- Points in favor or against the paper

The paper presents a promising and sound approach for checking correctness
of compiler optimizations. I would recommend acceptance of the paper.

Static analysis methods for validating compiler optimizations is known. It
is not clear if the proposed method presents any advantages compared to
these methods

5- Specific Comments for improvement of the paper
The paper states that the proposed method is better in practice than other
methods for proving correctness of compiler optimizations. No comparative
study has been provided. I would like to see the performance of the type
system on a real example. What is the semantic difference between the
proposed approach and that in [10]. Can't the approach in [10] be recast
as a type checking problem and vice versa?
It is not clear how you deal with intermediate variables in the target
code (without using the cut rule). In Related Work, you state that the
translation validation approach checks whether the source code and the
target code are bisimilar. Actually it checks whether the target code
refines the source code. Also it is not true that the translation
validation approach does not concern proving correctness of compiler
optimizations. Translation validation can be used to prove the correctness
of compiler optimizations






