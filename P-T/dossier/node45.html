<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Short-term Plans</TITLE>
<META NAME="description" CONTENT="Short-term Plans">
<META NAME="keywords" CONTENT="main">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="main.css">

<LINK REL="previous" HREF="node44.html">
<LINK REL="up" HREF="node44.html">
<LINK REL="next" HREF="node46.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html658"
  HREF="node46.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/next.gif"></A> 
<A NAME="tex2html654"
  HREF="node44.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/up.gif"></A> 
<A NAME="tex2html650"
  HREF="node44.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/prev.gif"></A> 
<A NAME="tex2html656"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/contents.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html659"
  HREF="node46.html">Documents on Service</A>
<B> Up:</B> <A NAME="tex2html655"
  HREF="node44.html">Future Plans in Research</A>
<B> Previous:</B> <A NAME="tex2html651"
  HREF="node44.html">Future Plans in Research</A>
 &nbsp; <B>  <A NAME="tex2html657"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->

<H4><A NAME="SECTION00340010000000000000">
<B>Short-term Plans</B></A>
</H4>
Currently, most of the design models used for system design are
state-based. Designs are typically expressed in an object-oriented
fashion where the relationship between classes is expressed using
class diagrams, while the behavior of each class is given by state
diagrams. In my current work [<A
 HREF="node50.html#GMRT:06">1</A>], I have explored
executable design models for distributed embedded systems where
the system behavior is expressed as a hybrid of state diagrams
(intra-component specification style) and sequence diagrams
(inter-component specification style). In future, I would like to
study the use of such hybrid design models for activities beyond
functionality validation, such as high-level performance analysis.
Such an approach will bring a wealth of concepts (which have
hitherto been exploited for functionality validation) into the
domain of performance analysis. In particular, the concepts of
symbolic execution and control/data abstractions have so far been
restricted to formal verification of distributed systems. Since
such concepts are ingrained in the execution semantics of our
hybrid models, in future, I plan to exploit them for efficient
performance analysis of distributed embedded systems.

<P>
Moreover, in the context of embedded system designs, one could
also study <EM>extra-functional artifacts</EM> -- such as critical
paths in the design model which contribute to the maximum
execution/response time of the corresponding software
implementation. From the model-level performance analysis, we can
generate representative critical paths or system scenarios which
can be fed to lower-level performance analyzers. Seamlessly
integrating model-level and lower-level analyzers to provide
timing guarantees will be a challenging issue.

<P>


<P>
In the longer term, I am studying the possibility of
developing <EM>bi-directional links</EM> between requirements, design
models and implementations in the context of embedded system
design. Currently, system design focuses on generating design
models from requirements, and system implementation from design
models. However, as most practitioners will agree, it is often
impossible to get a complete set of system requirements at one go.
Consequently, it is difficult to generate correct-by-construction
designs and implementation at one go. This makes it difficult (or
even impossible) to perform all of the validation at the model
level and none at the software level.
Now, when we perform testing/debugging of the software
implementations, if functional errors are found -- it very hard
to relate back the error to the model/requirement level. In the
longer term, I am thinking of studying the issue of <EM>backward
association between system implementations and design models.</EM>
Currently, there exist number of commercial tools for
(semi)-automatically generating software implementations from
system models specified in the Unified Modeling Language (UML).
However, the association between models and code is (mostly) a
forward one. There is hardly any mechanism for mapping back the
code elements to corresponding model elements. Even for state
diagrams (which form the key executable part of UML) many of the
model elements cannot be retrieved once C/C++/Java code has been
generated. Such backwards communication between software and
models can be crucial for communicating changes/fixes in the
software to the embedded system designer or even other
stakeholders. This is particularly important from a pragmatic
point of view since in reality embedded system design (currently)
involves lot of low-level optimizations at the implementation
level.

<P>
So, to effectively support model-driven development of embedded
systems for safety-critical applications, we need to seriously
build backward links between system implementations and system
models. We need to study whether <!-- MATH
 $software \rightarrow model$
 -->
<IMG
 WIDTH="150" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.gif"
 ALT="$software \rightarrow model$">
backward associations can be seamlessly integrated into UML design
tools, particularly those which proceed by (forward)
transformation of design models to implementations. Clearly, we
also need to study the nature of models suitable for such backward
associations - whether we take UML state diagrams or richer
models [<A
 HREF="node50.html#GMRT:06">1</A>] with UML-compatible notations. The ability
to relate code elements with model elements must also be
seamlessly integrated with various code-level debugging methods
-- model checking, slicing, fault localization or even performance
debugging (using execution-time analysis). Finally, as a
more ambitious goal, we can try to relate design models to
(informal) requirements -- once the backward association between
software and design models is established.

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html658"
  HREF="node46.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/next.gif"></A> 
<A NAME="tex2html654"
  HREF="node44.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/up.gif"></A> 
<A NAME="tex2html650"
  HREF="node44.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/prev.gif"></A> 
<A NAME="tex2html656"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents"
 SRC="file:/usr/local/teTeX/share/lib/latex2html/icons/contents.gif"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html659"
  HREF="node46.html">Documents on Service</A>
<B> Up:</B> <A NAME="tex2html655"
  HREF="node44.html">Future Plans in Research</A>
<B> Previous:</B> <A NAME="tex2html651"
  HREF="node44.html">Future Plans in Research</A>
 &nbsp; <B>  <A NAME="tex2html657"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
Abhik Roychoudhury
2006-10-18
</ADDRESS>
</BODY>
</HTML>
