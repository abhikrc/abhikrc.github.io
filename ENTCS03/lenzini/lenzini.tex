\documentclass{entcs}
\usepackage{entcsmacro}

%%%
%  Packages
%%%
\usepackage{color,graphicx}
\usepackage{amssymb,amsmath}
\usepackage{latexsym}
\usepackage{ifthen}

%%%
% Editing utilities
%%%

%% digit shortcut
\newcommand{\eg}{\emph{e.g., }}
\newcommand{\ie}{\emph{i.e., }}
\newcommand{\wrt}{\emph{w.r.t.~}}

%%%
% Macros
%%%

%%
%%
%%  ??? macroz ???
%%
%%

\newcommand{\TODO}[2][ic]
{$^{\fboxsep=1pt\fbox{\tiny #1}}$%
 \marginpar{\fbox{\parbox[t]{\marginparwidth}{\tiny #2}}}}
\newcommand{\TODOG}[1]{\TODO[Gab]{#1}}


\newcommand{\lts}{\mathit{LTS}}
\newcommand{\ltss}{\mathit{LTSs}}
\newcommand{\defs}{\mathit{Defs}}
\newcommand{\sse}{{\rm\ iff\ }}

\newcommand{\rep}[2][]
 {\ulcorner {#2} \urcorner^{#1}}
\newcommand{\irep}[2][]
 {\llcorner {#2} \lrcorner_{#1}}

\newcommand{\ppp}[2]{\langle{#1},{#2}\rangle}
\newcommand{\rname}[1]{\mbox{\small $\mathbf{#1}$}}
\newcommand{\labels}{\mathcal{L}}

%%%%%
%% Fabio macros
%%%%

\newcommand{\dia}[1]{\langle #1 \rangle}
\newcommand{\arco}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\sem}[1]{[\![#1]\!]}
\newcommand{\quot}[1]{\slash\!\!\slash {#1}}
\newcommand{\quotres}[2]{\slash\!\!\slash_{#1} #2}
\newcommand{\ct}[1]{{\cal #1}}
\newcommand{\frecciagiu}{\! \downarrow}

\newcommand{\alphaset}{\mathcal{A}}
\newcommand{\pdc}{\|}
\newcommand{\pdcres}[1]{\|_{#1}}

\newcommand{\mycomp}[1]{\overline{#1}}

%%%%
%% stefania macros
%%%

\def\qed{\hfill{$\Box$}}
\def\fine{\ \hfill{$\Box$}}

\newcommand{\mmid}{\ \ \mid \ \ }

\newcommand{\ar}        {\longrightarrow}
\newcommand{\trans}[1]{\stackrel{#1}{\ar}}
\newcommand{\Dtrans}[1]{\stackrel{#1}{\Imp}}

\newdimen\RuleWidth

\RuleWidth = 428pt
% First arg    0:   normal width
%              1:   max width
% Second arg   0:   normal size
%              1:   script size
\newcommand{\Rule}[4]{
\vcenter{
  \halign{
   \hfil\ ##\ \hfil\cr
   $
    \ifnum #2 > 0
     \scriptstyle
    \fi
    #3
   $
   \cr\noalign{\vskip1pt}
   \ifnum #1 > 0
    \omit\hrulefill\hbox to \RuleWidth{\hrulefill}\hrulefill
   \else
    \omit\hrulefill
   \fi
   \cr\noalign{\vskip1pt}
   $
    \ifnum #2 > 0
     \scriptstyle
    \fi
    #4
   $
   \cr}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Non Interference
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% high actions
\newcommand{\high}{\mathcal{H}}

%% low actions
\newcommand{\low}{\mathcal{L}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Modeling Fault Tolerance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% single fault action
\newcommand{\fault}{f}

%% fault actions set
\newcommand{\Faults}{\mathcal{F}}

%% failing modifier
\newcommand{\failing}[1]{{#1}_\Faults}

%% fault tolerant modifier
\newcommand{\faulttolerant}[1]{{#1}^{\#}_\Faults}

%% fault tolerant modifier
\newcommand{\faultt}[1]{{#1}^{\#}}

%% environment (process set using channel #1)
\newcommand{\env}[1]{\mathcal{E}_{#1}}

%% failing environment (fault scenarios)
\newcommand{\faultenv}{\env{\Faults}}

%% failing scenario alias
\newcommand{\faultscenarios}{\faultenv}

%% fault injector
\newcommand{\faultinjector}{F_{\Faults}}

%% fault scenarios (set)
\newcommand{\faultscenario}[1]{\mathfrak{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  CCS
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% action label set
\newcommand{\Lab}{\mathcal {L}}

%% action set
\newcommand{\Act}{\mathit {Act}}

%% action set with silent action
\newcommand{\Acttau}{\mathit {Act}_\tau}

%% defining equation
\newcommand{\eqdef}{\stackrel{\mbox{{\tiny def}}}{=}}

%% input
\newcommand{\inp}[1]{{#1}}

%% output
\newcommand{\out}[1]{\overline{#1}}

%% hide
\newcommand{\hide}{/}

%% restriction
\newcommand{\res}{\backslash}

%% ccsif
\newcommand{\ccsif}[3]
{\mathbf{if}\: #1 \: \mathbf{then}\: #2 \: \mathbf{else}\:
#3 \:}

%% nul
\renewcommand{\stop}{\mathbf{0}}

%%%%%%%%%%%%%%%%%%
% Labeled Transition Systems
%%%%%%%%%%%%%%%%%%

% set states
\newcommand{\ltsQ}{\mathcal{Q}}

% set states
\newcommand{\ltsq}{Q}

% transition relation
\newcommand{\ltsTR}{\rightarrow}

%%%%%%%%%%%%%%%%%%
%% GNDC Scheme
%%%%%%%%%%%%%%%%%%

% Sort
\newcommand{\sort}[1]{\mathit{Sort}(#1)}
% Top process
\renewcommand{\top}{\mathit{Top}}
% Top process
\renewcommand{\bot}{\mathit{Bot}}
% GNDC
\newcommand{\gndc}{\mathit{GNDC}}
% BNDC
\newcommand{\bndc}{\mbox{\emph{BNDC}}}
% NDC
\newcommand{\ndc}{\mbox{\emph{NDC}}}
% SNNI
\newcommand{\snni}{\mbox{\emph{SNNI}}}

%%%%%%%%%%%%%%%%%%
%% Logic
%%%%%%%%%%%%%%%%%%

% syntax
\newcommand{\true}{\mathtt {tt}}
\newcommand{\false}{\mathtt {ff}}
\renewcommand{\implies}{\Rightarrow}

%% satifability
\newcommand{\sat}{\models}

%%%%%%
% Header
%%%%%

\def\lastname{}

\begin{document}
\begin{frontmatter}
  \title{Logical Specification and Analysis of
      \\ Fault Tolerant Systems
      \\ Through Partial Model Checking}

\author{S. Gnesi, G. Lenzini \thanksref{gl-mail}\thanksref{ALL}}
  \address{Istituto di Scienze e Tecnologie Informatiche - C.N.R. \\
           Via G. Moruzzi 1, I-56100 Pisa, Italy}

%\author{G. Lenzini \thanksref{gabri-mail}}
%\address{Istituto di Scienze e Tecnologie Informatiche - C.N.R. \\
%Via G. Moruzzi 1 \\
%I-56100 Pisa, Italy}

\author{F. Martinelli \thanksref{fabio-mail}}
  \address{Istituto di Informatica e Telematica - C.N.R. \\
           Via G. Moruzzi 1, I-56100 Pisa, Italy}

  \thanks[ALL]{Gnesi and Lenzini are partially supported by the MIUR-CNR project SP4. Martinelli is supported by MIUR project
  ``Tools, techniques and methodologies for the information society''.}
  \thanks[gl-mail]{Email: \href{stefania.gnesi,gabriele.lenzini@isti.cnr.it}
  {\texttt{\normalshape \{stefania.gnesi, gabriele.lenzini\}@isti.cnr.it}}}

%\thanks[gabri-mail]{Email: \href{gabriele.lenzini@isti.cnr.it}
%{\texttt{\normalshape gabriele.lenzini@isti.cnr.it}}}

  \thanks[fabio-mail]{Email: \href{fabrio.martinelli@iit.cnr.it}
  {\texttt{\normalshape fabio.martinelli@iit.cnr.it}}}

\begin{abstract}
  This paper presents a framework for a logical characterization of fault
  tolerance and its formal analysis based on partial model checking
  techniques. The framework requires a fault tolerant system to be modeled
  using a formal calculus, here the CCS process algebra. To this aim we
  propose a uniform modeling scheme in which to specify a formal model of the
  system, its failing behaviour and possibly its fault-recovering procedures.
  Once a formal model is provided into our scheme, fault tolerance - with
  respect to a given property - can be formalized as an equational
  $\mu$-calculus formula. This formula expresses, in a logic formalism, all
  the fault scenarios satisfying that fault tolerance property. Such a
  characterization understands the analysis of fault tolerance as a form of
  analysis of open systems and, thank to partial model checking strategies, it
  can be made independent from any particular fault assumption. Moreover this
  logical characterization makes possible the fault-tolerance verification
  problem be expressed as a general $\mu$-calculus validation problem, for
  solving which many theorem proof techniques and tools are available. We
  present several analysis methods showing the flexibility of our approach.
\end{abstract}

\begin{keyword}
  Fault Tolerant Systems, Formal Verification, Partial Model Checking.
\end{keyword}
\end{frontmatter}

\section{Introduction}

%% May fault tolerance benefit from techniques developed within the security
%% analysis theory? Studies about possible relationships between
%% dependability and security suggest that modalities of interaction
%% are possible. For example in~\cite{M95:npsw}
%% Meadows investigates about the advantages of applying
%% fault tolerance strategies in security,
%% where in turn only fault-prevention approaches are usually applied.
%% The possibility of a common approach in fault tolerance and security
%% has been, for example, discussed in~\cite{J98:nspw}. In that
%% paper, Jonsson argues that both typical fault-tolerant properties
%% (such as reliability, availability and safety) and security properties
%% could be integrated and described into a common framework requiring a
%% system and its (eventually faulty) environment to be specified. Later
%% in~\cite{SWD99:ssd,SD98:misc} the concept of non-interference, widely
%% applied in formal theories of security (\eg see~\cite{FGM00:icalp}),
%% was used to reason about various classes of safety properties.

%% Anyway for many years the amount of results in security analysis
%% appeared as a minority with respect to the ones in dependability and
%% fault tolerance. Nowadays it can be observed an opposite trend, for
%% example by looking at the great amount of results that research in
%% security analysis has produced along these last years. This implies,
%% as suggested by Meadow and MacLean in~\cite{MM98:csftsa}, that the
%% tim e is ripe for a novel comparison between the two disciplines.


Following a general direction pointing out that it exists a beneficial
interactions between strategies of analysis in security and fault tolerance
(\eg see~\cite{J98:nspw,MM98:csftsa,SWD99:ssd}), this paper inquires about the
analogy between fault tolerance and a particular strategy for computer
security analysis \ie \emph{partial model
  checking}~\cite{LICS::Andersen1995,M98:csfw,fabiosos}.

As in many approaches using formal methods in the specification and validation
of fault tolerant system (\eg see~\cite{G99:acm,BFG02:stvr}), this paper first
requires a system, its failing behaviour (with respect to fault occurrences)
and its fault-recovering procedures to be formally specified as a finite state
term in some process algebras, for example the CCS~\cite{M89}. Then this paper
requires desired properties to be formalized in logical formalism, here a
variant of the $\mu$-calculus~\cite{BS01}. A property expressed in such a
logic can be formally checked over a formal model of the system under
analysis, which is typically expressed by means of a state machine or
transitions system.

The validation framework we propose falls into the \emph{open system}
paradigm, where a system is considered acting in an \emph{environment} able to
interact with the system. Anyway, the fact of considering a ``general
environment'' able to invoke, in any order, any action of the system's
interface, usually brings unpleasant drawbacks. The first is the well-known
state space explosion, and the second is that unrealistic situations may arise
during the analysis~\cite{GPB02:ase}.

As a solution in this paper we are interested to verify a system $P$ in a
well-characterized environment $\faultinjector$. This latter, by acting as a
fault-injector, is able to interact with the system only through the specified
set $\Faults$ of fault actions. Moreover, differently to the usual strategies
requiring the fault-injector to be specified (\eg see~\cite{TWM02:sac}), we
treat $\faultinjector$ as a unspecified component of the system. In this way
we mean to check the reliability of a system model with respectively to any
potential occurrences of faults.

Moreover by using \emph{partial model checking}
strategies~\cite{LICS::Andersen1995}, the fault tolerance analysis
problem can be reduced to a validity problem in the
$\mu$-calculus. Briefly the idea is the following: proving that $(P
\parallel \faultinjector) \setminus \Faults$ satisfies a fault
tolerant property \eg a $\mu$-calculus formula $\varphi$, is
equivalent to prove that $\faultinjector$ satisfies a modified formula
$\varphi \quot{P}$, where $\quot{P}$ is the partial
evaluation for the parallel composition and restriction operators. In
this way $\varphi \quot{P}$ characterizes exactly the
scenarios of faults the system is resilient to. As a consequence, by
considering the characteristic formulas $\varphi_{\Faults}$ of all the
possible fault scenarios, checking if $P$ is fault tolerant is
equivalent to check the validity of $\varphi_{\Faults} \Rightarrow
\varphi \quot{P}$.

Once such a logical characterization of fault tolerance is given, several
analysis techniques may be adopted. Some of them may also lead to efficient
analysis methods for certain properties. In particular, we identify a class of
$\mu$-calculus formulas for which the analysis is
very efficient.

\section{Modelling Fault-Tolerant Systems}
\label{modelingfts:sec}%

This section presents a uniform scheme where a fault tolerant system may be
specified as a process algebra term. To specify a system we will use the
CCS~\cite{M89}, but our framework is completely general and it can be easily
restated for other process algebras as well (\eg CSP~\cite{Hoare85} or
$\pi$-calculus~\cite{milner:92a}).

\subsection{CCS}
We briefly remind some notation and concept about CCS that will be used in the
following. CCS assumes a set of $\Lab$ of \emph{actions}.  Each action to
represent emitted signals or (if over-lined) received ones.  Actions $\out{a}$
and $\inp{a}$ (\ie complementary send and receive actions) are called
\emph{co-actions}. The operator $\space^-$ is a bijection with
$\overline{\overline{a}} = a$. The special symbol $\tau$ is used to model any,
unobservable to the environment, \emph{internal action}.  Let $\Act =
\inp{\Lab} \cup \out{\Lab}$ be the set of visible actions, and $\Acttau = \Act
\cup \{\tau\}$ denotes the full set of possible actions.  In CCS syntax,
processes are defined by the following grammar:%

\begin{eqnarray*}
P, Q \; & ::= & \; \stop \mmid a.P \mmid P + Q \mmid P
\parallel Q \mmid P \res \mathcal{A} \mmid P[f] \mmid X
\end{eqnarray*}%

Informally $\stop$ is the process that does not perform any action; $a.P$ is
the action prefix operator with $a\in\Acttau$; $P + Q$ can, non
deterministically, choose between the behaviour the process $P$ or that of the
process $Q$; $\parallel$ is the parallel operator; $P \res {\cal A}$ is the
action restriction operator over the set of action ${\cal A} \subset \Act$,
meaning that actions $a \in{\cal A}$ cannot be performed. This operator is
used to specify processes which must synchronize on actions $\out{a}$ and
$\inp{a}$. $P[f]$ is the re-naming operator, renaming each $a$ into $f(a)$.
Additionally we assume that every process identifier $X$ has a defining
equation of the form $X \eqdef P$ describing its behavior.

The semantics of CCS is given operationally over labeled transition systems
($\lts$) (see~\cite{M89}). A $\lts$ is a tuple $(\ltsQ, \ltsq_0, Act_\tau,
\trans{})$, whose transition relation $\trans{}$ defines the usual concept of
derivation in one step: $P \trans{a} P'$ means that process $P$, by executing
action $a$, evolves in one step in the process $P'$, while we write $P
\trans{a}$ to underline that $P$ can perform action $a$ to evolve in some
process. Finally, we write $\trans{}_{*}$ the obvious transitive and reflexive
closure of $\bigcup_{a \in \Acttau}\trans{a}$.  In the following we let
$Der(P)=\{P'| P \trans{}_{*} P'\}$, $Sort(P)=\{a: a \in \Acttau, \, \exists P'
\in Der(P), P' \trans{a}\}$, and $\env{\cal H}=\{X: Sort(X)\subseteq {\cal H}
\}$, where ${\cal H}$ is a set of actions.

\subsection{Specifying a System}
\label{specifying:sec}
Talking about formal models of fault-tolerant systems we will refer to the
following notation, which is a model-oriented version of the concepts defined
in~\cite{L95}:

\begin{itemize}
\item
{\em A System} is modelled as a finite state CCS process $P$, composed by a set of
processes communicating each other and interacting with the environment
through the execution of actions.
%
\item {\em A Failing System} is modelled as a CCS process $P_\Faults$ obtained
  by extending the processes in $P$ with the possibility of executing
  particular external actions from a set $\Faults$ of {\em fault
  actions}. In other words each kind of fault is modelled explicitly
  as an action $\fault \in \Faults$.  The execution of an action $f$
  corresponds to the occurrence of a fault. The specification
  $P_\fault$ of the failing system is obtained by introducing
  occurrences of the possible fault action $f$ in the model of the
  system $P$. If the action $\fault$ is executed in a state of a
  system, then the failure mode of the system is exhibited, otherwise,
  the system goes on with its behaviour. For instance, $P_f = P +
  f.P'$ denotes the process that can behave as $P'$ in the case of
  occurrence of fault $f$.%

\item {\em A Fault Tolerant (Candidate) System} is modelled as a process
  $\faulttolerant{P}$, obtained by extending the failing model $P_\Faults$
  with additional processes realizing error-recover strategies, in accordance
  to some fault tolerant design strategy (\eg replication of component, triple
  modular redundancy, voting etc.).  Generally speaking, the application of
  tolerance techniques in modelling leads to a process $\faulttolerant{P}$
  that, described in the CCS notation, have the indicative form:%

\begin{displaymath}
\faulttolerant{P} =
(P^{(1)}_\Faults \parallel \cdots \parallel P^{(n)}_\Faults \parallel
Q) \res \mathcal{A}
\end{displaymath}%

where (a) $P^{(i)}_\Faults$ is the $i$-th replica of $P_\Faults$, with
eventually an appropriate renaming of actions; (b) $Q$ is the process
modelling the extras components \eg a voter; (c) $\mathcal{A} = \{a_1, \cdots,
a_h\}$, $a_i \not\in {\Faults}$, are the label of synchronisation actions
between $P^{(i)}_\Faults$'s and $Q$.
\end{itemize}%

Let us observe that, differently from other approaches, for example
the one in~\cite{BFG02:stvr}, we will not assume any specific
\emph{fault assumption} in $\faulttolerant{P}$.  Precisely we did not
express, in $P$, any assumption about the possibility of occurrence of
faults, but we let fault assumptions to be characterised by the
environment.

\subsection{Fault Assumption Models}

We now consider fault tolerant analysis as the analysis of an \emph{open
  system} acting in a general and unspecified \emph{faulty environment}. This
approach has been widely applied in system security analysis (\eg
see~\cite{M98:csfw,fabiosos}) and we will show how it could be successfully
applied in fault tolerance analysis too.

In our case the environment $F_\Faults$, acting as a fault injector, is able
to induce any fault in the system via actions in $\Faults$. So, if
we assume that the occurrence of the fault is always induced by a process
$F_\Faults$, the schenario we are proposing is the following:%

\begin{equation}
\label{failing+:eq}
(\faulttolerant{P} \parallel F_\Faults) \res \Faults
\end{equation}%

where $\faulttolerant{P}$ is a model of a candidate fault tolerant
system.  Again we underline that the way we model the faulty behaviour
differs from~\cite{BFG02:stvr} where, in turn, the fault-injector
could also exhibit part of the system behaviour. This clear separation
between the process and the fault-injector makes the usage of partial
model checking (see Section~\ref{logicchar:sec}) feasible.  Before
going on it is worth to observe that in (\ref{failing+:eq}) fault
actions are hidden (\ie restricted). This implies that $P_\Faults$ and
$F_\Faults$ could synchronize only on fault events and that faults are
indeed internal (\ie not observable) actions of the failing
systems. This means that our analysis lays at the abstraction level
where what it is really observable, in a failing system, is only its
behaviour. In practice, a failing systems should be either resilient
to faults or the presence of faults should be highlighted by its
subsequent behaviour.

In such a framework, then the set of all the possible fault-injector processes
represents our set of all possible fault assumptions:
%
\begin{definition}
\label{fault-ass:def}[Fault Assumption Models]
The set $\faultscenarios$ of \emph{fault assumption models} is given by
definition:
$$
\faultscenarios = \{ F: \mathit{Sort}(F) \subseteq \Faults \}
$$ In other words, $\faultscenarios$ is the set of all CCS processes
whose alphabet of actions is in $\Faults$.
\end{definition}%

Generally speaking a \emph{fault tolerance} system is expected to behave
correctly despite faults.  Anyway different meaning of fault tolerant
behaviour may be defined. For example a system may be required to be:
\emph{fail safe}, when failures cause transition in a state in which no
catastrophic event can occur; \emph{fail stop} when failures cause a
stop in delivering a service, or \emph{fail silence} when failures
provide only a temporarily interruption of the services.

\subsection{Equational $\mu-$calculus}
\label{logsec}
Equational $\mu$-calculus is a process logic which extends
$\mathit{HML}$~\cite{HM85:acm} with fix-point equations in order to reason
directly about recursive definitions of properties. It permits us to analyse
non terminating behaviour of systems.  It is a powerful temporal logic which
subsumes several other state based logic such as $CTL,CTL^{*}$ and
$ECTL^{*}$~\cite{emerson}, as well as action based logic as $ACTL$,
$ACTL^{*}$~\cite{DV90:lncs}. Equational $\mu$-calculus is based on fix-point
equations that substitute recursion operators. Let $X$ be a variable ranging
over a set $\mathcal{V}$ of variables, then a minimal (maximal) fix-point
equation is $X =_{\mu} \phi$ ($X=_{\nu} \phi$), where $\phi$ is an
\emph{assertion}, that is a simple modal formula without recursion operators.
The syntax of the assertions ($\phi$) and of the lists of equations
($\varphi$) is given by the following grammar:
%
$$
\begin{array}{p{3cm}cl}
\emph{assertion} & \phi:= &  X \mid \true \mid \false \mid
\phi\wedge \phi' \mid \phi\vee \phi' \mid \dia{a}\phi \mid [a]\phi  \\
\emph{equations list} & \varphi::= & (X =_{\nu} \phi) \ \varphi\ \mid (X =_{\mu} \phi) \ \varphi \ \mid  \epsilon
\end{array}
$$%

It is assumed that variables appear only once on the left-hand sides of the
equations of the list, the set of these variables will be denoted as
$\defs(\varphi)$. A list of equations is closed if every variable that appears
in the assertions of the list is in $\defs(\varphi)$.

Let be $\mathcal{M} = (\ltsQ, \ltsq_0, Act_\tau, \trans{}) $ a $\lts$ and
$\rho$ an environment function that assigns subset of $\ltsQ$ to the variables
appearing in the assertion of $\varphi$ out of $\defs(\varphi)$.  As notation,
we use in the following $\sqcup$ to represent union of disjoint environments.
Let $\sigma$ be in $\{\mu,\nu\}$, then $\sigma U.f(U)$ represents the $\sigma$
fix-point of the function $f$ in one variable $U$. The semantics
$\sem{\varphi}_{\rho}$ of the equation list is an environment which assigns
subsets of $\ltsQ$ to variables in $\defs(\varphi)$:

$$
\begin{array}{rcl}
\sem{\epsilon}_{\rho}& = & []\\
\sem{(X =_{\sigma} \phi) \varphi}_{\rho} & = &
\sem{\varphi}_{(\rho\sqcup [U'\backslash X])}\sqcup [U'\slash X] \\[2ex]
\end{array}
$$%

where $U'  =  \sigma U.\sem{\phi}'_{(\rho\sqcup [U\slash X]\sqcup
  \rho'(U))}$, and $\rho'(U)  =  \sem{\varphi}_{(\rho\sqcup [U\slash X])}$.
The semantics $\sem{\phi}'_{\rho}$ of an assertion $\phi$ is the
same as for the $\mu$-calculus:%
$$
\begin{array}{c}
\begin{array}{l@{,\quad}l@{,\quad}l@{,\quad}l}
\sem{\true}'_{\rho} = \ltsQ &
\sem{\false}'_{\rho} = \emptyset &
\sem{X}'_{\rho} = \rho(X) &
\sem{X}'_{\rho} = \rho(X)
\end{array}  \\
 \begin{array}{l@{,\quad}l}
\sem{\phi_{1}\wedge \phi_{2}}'_{\rho} = \sem{\phi_{1}}'_{\rho}\cap \sem{\phi_{2}}'_{\rho} &
\sem{\dia{a}\phi}'_{\rho} =
\{Q|\exists Q':Q\arco{a} Q'{\rm\ and\ }
Q'\in \sem{\phi}'_{\rho}\}
\\[1ex]
\sem{\phi_{1}\vee \phi_{2}}'_{\rho} = \sem{\phi_{1}}'_{\rho}\cup
\sem{\phi_{2}}'_{\rho}&
\sem{[a]\phi}'_{\rho} =
\{Q|\forall Q':Q\arco{a} Q'{\rm \ implies\ }
Q'\in\sem{\phi}'_{\rho}\}
\end{array}
\end{array}
$$

Informally $\sem{(X =_{\sigma} \phi) \varphi}_{\rho}$ says that the solution
to $(X=_{\sigma} \phi) \varphi$ is the $\sigma$ fix-point solution $U'$ of
$\sem{\phi}'_{\rho}$ where the solution to the rest of the list of equations
$\varphi$ is used as environment.  We write $\ltsq, \ct{M}\models \varphi
\downarrow X$ as notation for $\ltsq \in \sem{\varphi}(X)$ when the
environment $\rho$ is evident from the context or $\varphi$ is a closed list
(\ie without free variables); furthermore $X$ must be the first variable in
the list $\varphi$.

%%%%%%%%%%%%%%%%%%%%%%
% LOGIC PART
%%%%%%%%%%%%%%%%%%%%%%

\section{Logic Characterisation of Fault Tolerance}
\label{logicchar:sec}%

This section explains how the fault tolerance verification problem can be
characterised as a validation problem of logic formulas. This
characterisation is prevalently based on a technique called \emph{partial
  model checking}~\cite{LICS::Andersen1995}, while the automatic verification is
possible afterwards by theorem proving. It is worth noticing that the same
approach has been proposed for security analysis \cite{M98:csfw,fabiosos}.

\subsection{Partial Model Checking}%

This technique relies upon compositional methods for proving
properties of concurrent processes specified in terms of a {\em
process algebra}.  It has been presented in this formulation by
Andersen~\cite{LICS::Andersen1995}. In the following we use
$P\pdcres{\alphaset} Q$ as a short cut for $(P \parallel Q)\res
\alphaset$.  The intuitive idea underlying the partial evaluation is the
following: proving that $P \pdcres{\alphaset} Q$ satisfies $\varphi$
is equivalent to prove that $Q$ satisfies a modified formula
$\varphi\quotres{\cal A}{P}$, where $\quotres{\cal A}{P}$ is the
partial evaluation function for the parallel composition operator (see
\cite{LICS::Andersen1995}). In Fig.~\ref{tableparev1:table} we will
describe the partial evaluation function for the CCS operator
$\parallel_{\cal A}$ where ${\cal A} \subseteq \Act$.

% Hence, the behaviour of a component has been partially
% evaluated and the requirements are changed in order to respect this
% evaluation.  This should appear clear if one analyses the partial
% evaluation rule for the formula $\dia{\tau}\phi$, \wrt the $\pdc$
% operator. By inspecting the inference rules, we can note that the
% process $P
% \pdcres{\alphaset} Q$ (with $Q$ unspecified component) can perform a $\tau$
% action by exploiting one of the three possibilities:
%
% \begin{itemize}
% \item the process $Q$ performs an action $\tau$ going in a state $Q'$
% and $P \pdcres{\alphaset} Q'$ satisfies $\phi$; this is taken into
% account by the formula $\dia{\tau}(\phi\quot{P})$, %
%
% \item the process $P$ performs an action $\tau$ going in a state $P'$
% and $P' \pdcres{\alphaset} Q$ satisfies $\phi$, and this is considered
% by the disjunctions $\bigvee_{P\arco{\tau} P'} \phi\quot{P'}$, where
% every formula $\phi\quot{P'}$ takes into account the behaviour of $Q$
% in composition with a $\tau$ successor of $P$.  %
%
% \item the last possibility is that the $\tau$ action is
% due to the performing of two complementary actions by the two
% processes. So for every $a-$successor $P'$ of $P$ there is a formula
% $\dia{\mycomp{a}}(\phi\quot{P'})$.
% \end{itemize}%

In \cite{IB-B941065,LICS::Andersen1995,nielsen},  we can also find the
proofs of the following lemma:%

\begin{lemma}
\label{lemmapar}
Given a process $P \pdcres{\alphaset} Q$ (where $P$ is finite-state)
and an equational specification $\varphi \frecciagiu\! X$ we have: $$P
\pdcres{\alphaset} Q \models (\varphi \frecciagiu X) \sse Q \models
(\varphi \frecciagiu X)\quotres{\cal A}{P}$$
\end{lemma}%

The size of the formula obtained after the partial model checking
procedure is polynomial in the size of the process and the formula.
Remarkably, this function is  exploited in \cite{LICS::Andersen1995}
to perform model checking efficiently \ie both $P$ and $Q$ are
specified.  In our setting, the process $Q$ will be not specified.

\begin{figure}[h]
\hrulefill \\
{\small \noindent Supposing
$\ct{M} = (\ltsQ, \ltsq_0, \Acttau, \ltsTR\}$ be
a finite state $\lts$, where $\ltsQ = \{\ltsq_0, \ldots,
\ltsq_n\}$:%
\begin{center}
$$
\begin{array}{l@{\quad = \quad}ll}
     (\varphi \frecciagiu X)\quotres{\cal A}{\ct{M}} &  (\varphi
     \quotres{\cal A}{\ct{M}})\frecciagiu Q_{0},
\\[0.2ex]
     \qquad  \epsilon\quotres{\cal A}{\ct{M}} & \epsilon
\\[0.2ex]
(X=_{\sigma} \phi) \varphi \quotres{\cal A}{\ct{M}} &
((X_{Q}=_{\sigma} \phi\quotres{\cal A}{Q})_{Q \in \{Q_{0},\ldots ,Q_{n}\}})(\varphi )\quotres{\cal A}{\ct{M}}
\\[0.2ex]
X \quotres{\cal A}{Q} & X_{Q}
\\[0.2ex]
\dia{a}\phi \quotres{\cal A}{Q}  &  \dia{a}(\phi\quotres{\cal A}{Q})\vee
\bigvee_{Q\arco{a} Q'}  \phi\quotres{\cal A}{Q'},
\ \ \ {\rm if\ } a\not =\tau \wedge a\not \in \alphaset
\\[0.2ex]
\dia{a}\phi \quotres{\cal A}{Q}  &  {\false},\ \ \ {\rm if\ } a\in \alphaset
\\[0.2ex]
\dia{\tau} \phi \quotres{\cal A}{Q} &  \dia{\tau}(\phi\quotres{\cal A}{Q}) \vee
\bigvee_{Q\arco{\tau} Q'} \phi\quotres{\cal A}{Q'}
\vee \bigvee_{Q\arco{a} Q'} \dia{\mycomp{a}}(\phi  \quotres{\cal A}{Q'})
\\[0.2ex]
%\mbox{[$a$]$\phi$}\quotres{\cal A}{Q}    &
%\mbox{[$a$]($\phi$\quotres{\cal A}{Q})} \wedge \bigwedge_{Q\arco{a} Q'}
%\phi\quotres{\cal A}{Q'},\ \ \ {\rm if\ } a\not = \tau \wedge a\not\in \alphaset
%\\[0.2ex]
%\mbox{[$a$]$\phi$}\quotres{\cal A}{Q} &  {\true},\ \ \ {\rm if\ } a\in \alphaset
%\\[0.2ex]
%\mbox{$[\tau]\phi$} \quotres{\cal A}{Q}  &  \mbox{$[\tau](\phi$\quotres{\cal A}{Q})}
%\wedge \bigwedge_{Q\arco{\tau} Q'} \phi\quotres{\cal A}{Q'} \wedge
%\bigwedge_{Q\arco{a} Q'} \mbox{$[\out{a}$]($\phi$ } \quotres{\cal A}{Q'})
%\\[0.2ex]
%   \phi_{1}\wedge \phi_{2}\quotres{\cal A}{Q}  &  (\phi_{1}\quotres{\cal A}{Q})\wedge
%     (\phi_{2}\quotres{\cal A}{Q}),
%\\[0.2ex]
%     \phi_{1}\vee \phi_{2}\quotres{\cal A}{Q} & (\phi_{1}\quotres{\cal A}{Q})\vee
% (\phi_{2}\quotres{\cal A}{Q})
%\\[0.2ex]
%    {\true}\quotres{\cal A}{Q}   & {\true}
%\\[0.2ex]
     {\false}\quotres{\cal A}{Q} & {\false}
\end{array}
$$
\end{center}}
\vspace{-0.3cm}
\hrulefill
%\protect{\label{tableparev1}}
\caption{The partial evaluation function for $\pdcres{\alphaset}$. We have
  left out the cases for $[a]\phi$, $\wedge$ and $\true$. They are
  immediate duals of $\dia{a}\phi$, $\vee$ and $\false$.}
\protect{\label{tableparev1:table}}
\end{figure}

\subsection{Fault Tolerance Analysis Through Partial Model Checking}
This section shows how to formalize fault tolerance using partial
model checking.  We start considering a system model $P$ and its
fault-tolerant version $P^\#_\Faults$.  Let us suppose $\varphi$ be an
equational $\mu$-calculus formula expressing some desirable behaviour of a
system even in presence of faults. In a fault tolerance analysis we are
interested in understanding in which \emph{fault assumption}
$F_{\Faults}$, the specification $P^\#_\Faults$ preserves $\varphi$. The
set of such fault assumption can be formalized as:
%
\begin{equation}
\label{ft:eq}
\faultscenario{F}_\varphi^P = \{F_\Faults: (\faulttolerant{P}
\parallel F_\Faults) \res \Faults \sat \varphi \}
\end{equation}
%
The previous set may be considered a characterization of the Fault Tolerance
of $\faulttolerant{P}$.
Indeed\footnote{Here $\faultscenarios$ is the set
of all fault assumption, see Definition~\ref{fault-ass:def}.},
if $\faultscenarios = \faultscenario{F}_\varphi^P$
then it means that no fault assumption is able to force
$\faulttolerant{P}$ not to satisfy $\varphi$.%

\begin{definition}[Logic Characterisation of Fault Tolerance 1]
  A process $\faulttolerant{P}$ is \emph{fault tolerant \wrt the logical
    property $\varphi$} if and only if $\faultscenarios =
  \faultscenario{F}_\varphi^P$.
\label{ftcar}
\end{definition}%

However, due to its implicit definition, Def. (\ref{ft:eq}) has not a
practical usage.  Here, we exploit the partial model checking
techniques to find a more suitable characterization for
(\ref{ft:eq}). In fact, we can write: %

\begin{equation}
\label{ftpmc:eq}
\faultscenario{F}_\varphi^P =
\{F_\Faults: F_\Faults \sat \varphi \quotres{\Faults}{\faulttolerant{P}} \}
\end{equation}%
where $\varphi \quotres{\Faults}{\faulttolerant{P}}$ is obtained by using partial
model checking of $\varphi$ \wrt $\faulttolerant{P}$.

Such a definition of $\faultscenario{F}_\varphi^P$ is easier to be
managed since corresponds to common representation of sets and permits
to define as a validity checking problem the fault tolerance of a
process \wrt a formula. At this point we can formulate our logic
characterization of fault tolerance.%

\begin{definition}[Logic Characterisation of Fault Tolerance 2]
  We say that a process $\faulttolerant{P}$ is \emph{fault tolerant \wrt the
    logical property $\varphi$} if and only if $ \varphi
    \quotres{\Faults}{\faulttolerant{P}}$
  is a valid formula \wrt processes in $\faultscenarios$.
\label{logcar}
\end{definition}%

It is easy to prove that:
\begin{proposition} A process $\faulttolerant{P}$
  enjoys Definition~\ref{ftcar} if and only if it enjoys
  Definition~\ref{logcar}.
\end{proposition}%

\section{Analysis techniques}
\label{logicanalysis:sec}

We have shown how the {\em fault tolerance} of $\faulttolerant{P}$ \wrt the
property $\varphi$ may be expressed as a validity statement in the
$\mu$-calculus. Thus one could use either the standard validity checking
algorithms (\eg see~\cite{Street89}) or the proof system developed in
\cite{LICS95*14}. Clearly, the complexity of checking {\em fault tolerance}
of a system $\faulttolerant{P}$ \wrt a formula $\varphi$ in any fault
assumption turns out to be exponential in the size of the formula obtained
after the partial evaluation, which is in turn polynomial in the size of the
system $\faulttolerant{P}$ and $\varphi$.

\subsection{Fault Tolerance Analysis as  Theorem Proving}
This complexity cost has however the advantage of making very simple the
analysis of a system $\faulttolerant{P}$ \wrt a wide class of fault
assumption scenarios. In particular, such scenarios could be denoted by
another  $\mu$-calculus formula $\varphi_{\Faults}$.
 The verification problem is still a validity checking one
with respect to the formula $\varphi_{\Faults}\implies \varphi
\quotres{\Faults}{\faulttolerant{P}}$. Formally:

\begin{definition}[Logic Characterisation of Fault Tolerance 3]
  Let $\varphi_{\Faults}$ to be the characteristic formula for a set of fault scenarios.
   We say that a process $\faulttolerant{P}$ is \emph{fault
    tolerant \wrt the logical property} $\varphi$ if and only if
  $\varphi_{\Faults} \implies \varphi \quotres{\Faults}{\faulttolerant{P}}$ is valid.
\end{definition}%

\subsection{Fault Tolerance against a fixed Scenario}
We recall that partial model checking has been advocated as an
efficient method for performing model checking by Andersen. Assume to
have a given fault scenario corresponding to a finite-state CCS
process. Now let us assume that $\faulttolerant{P}$ is indeed a
parallel composition of $k$ processes $P_{1}\pdc \ldots \pdc P_{k}
\parallel \stop$, and testing if it satisfies a formula $\varphi'$ is easy by
applying several times the partial model checking function.

In fact we obtain a formula $\varphi'_{1}$ that $P_{2} \parallel \ldots
\parallel P_{k} \parallel \stop$ must satisfy.  Here, one could apply some
logical simplifications on the formula $\varphi'_{1}$, in order to
obtain a smaller and so more tractable formula.  After $k$
applications of the partial model checking, we obtain that the stuck
process $\stop$ must satisfy a formula $\varphi'_{k}$.  The model
checking of a formula \wrt the stuck process is usually very
efficient.  Thus, the model checking of a system which consists of $k$
parallel-running processes is reduced, through partial model checking,
to the model checking of the stuck process $\stop$.

\subsection{Universal formulas}

A way to obtain a more efficient analysis is to consider a variant of {\em
universal } $\mu$-calculus formulas (\eg see \cite{kupf}).  Here, we specify
this class for the equational $\mu$-calculus. When a {\em universal}
equational is translated into the standard one through the application of the
Beki$\breve{{\rm c}}$ theorem in \cite{bekic}, we get standard {\em universal}
formula.  A nice feature of this class of formulas is that their validity
problem is co-NP-complete (\cite{kupf}) rather than EXP-time (\cite{Street89}). Moreover, a
subclass of such formulas \ie the conjunctive ones, has a validity problem
whose complexity is linear in the size of the formula.

\begin{definition}
  The set of \emph{universal formulas} ($\forall MC$, for short) is a
  class of the equational $\mu$-calculus formulas where no $\dia{a}$
  operator is present.  The set of {\em universal conjunctive formulas}
  ($\forall_{c}$MC, for short) is the subset of $\forall MC$ formulas
  containing only conjunctions.
\end{definition}

Several interesting properties may be written as {\em universal
formulas} \ie the safety ones.  The key property is that partial model
checking of {\em universal} formulas \wrt contexts as the ones used in
(\ref{ftpmc:eq}) gives again {\em universal} formulas.
%
\begin{proposition}
Given a {\em universal formula} $\phi$, a fault
tolerant process $\faulttolerant{P}$, a fault injector $F_\Faults$
then
%
$$(\faulttolerant{P} \parallel F_\Faults) \res \Faults \sat
\varphi \quad \mbox{ if and only if } \quad  F_\Faults\models \varphi\quotres{\Faults}{\faulttolerant{P}}
$$
%
and $\varphi\quotres{\Faults}{\faulttolerant{P}}$ is a {\em universal formula}.
\end{proposition}%

The proof relies on the fact that the partial model checking of the
$[a]\phi$ operator gives a formula which consists of a conjunction of
such operators.  The same proposition holds for the {\em universal
conjunctive} ones. The nice feature of these formulas is that their
validity problem is the complementary one of the satisfiability problem of the
negated of such formulas that turns out to be a disjunctive one in the
sense of \cite{JW:autmcr}, whose satisfiability problem can be decided
in linear time in the size of the formula.

\subsection{Linear time formulas}
As a final consideration we can observe that, when the formula under
examination $\varphi$ is a linear time formula, i.e. that holds for a system iff it holds
in each trace of the system, we can reduce the fault tolerance problem
\wrt such a formula to a fault tolerance problem \wrt a specific fault
assumption, precisely:

$$ Top_{\Faults} = \sum_{f\in \Faults} f.Top_{\Faults} +
\mycomp{f}.Top_{\Faults} $$%

Consider the set $\Phi$ of linear time formulas that are
true in a model if and only if are true in each computation path take
as a model. Several interesting fault-tolerance properties are in this
class.

\begin{proposition}
\label{top:pro}
$\faulttolerant{P}$ is {\em fault tolerant} \wrt $\varphi \in \Phi$ if
and only if $\faulttolerant{P}$ is {\em fault tolerant} \wrt $\varphi$
against only $Top_{\Faults}$.
\end{proposition}%

%%%%%%%%%%%%%%%%%%%%%%% 
%  example
%%%%%%%%%%%%%%%%%%%%%%% 
\section{Example}

As an example, we will illustrate a CCS model of a Triple Modular
Redundancy (TMR) system, taken from~\cite{B97}.  For sake of
conciseness we will write our example in a value passing style CCS,
which is knows to be a shortcut for CCS. The basic component is a
simple module implementing the identity function, which naively
returns the same value received in input.  Here we assume that values
are taken from a set of binary values $\mathit{Val}$.  The actions
{\tt mi} and {\tt mo} are used to communicate module inputs and
outputs.%

$$
P \eqdef \inp{mi}(x).\out{mo}(x).P
$$%

In modelling the corresponding failing module we assume that in case
of fault any value from $\mathit{Val}$, it may be produced in
output. In accordance to our modelling framework, the fault is assumed
to be caused by a special fault action $f$ triggered by the
environment.%

$$
P_f \eqdef
    \inp{mi}(x).(\out{mo}(x) +
    \inp{f}.\sum_{y \in \mathit{Val}}\out{mo}(y)).P_f +
    \inp{f}.(\inp{mi}(x).\sum_{y \in \mathit{Val}}\out{mo}(y)).P_f
$$%

Note that in modelling the failing behaviour we have assumed that a
fault may happen everywhere in the module. Different faulty behaviours
can be taken into consideration, for example by assuming a module to
fail only after inputs. The (candidate) fault system
$\faulttolerant{P_f}$, may be designed using the classic solution of
Triple Modular Redundancy, where three instances of the module $P_f$
are composed with the additional modules of a splitter $S$ and a voter
$V$. We want the splitter to deliver the input value to each of the
three instances of the module $P_f$, respectively $P^{(1)}_f,
P^{(2)}_f$ and $P^{(3)}_f$, so we define an indexed version of the
module: %

$$
P^{(i)}_f \eqdef P_f[{\tt mi}_i/{\tt mi}, {\tt mo}_i/{\tt mo}]
$$%

An indexed from $P$ can be defined as for $P_f$.  If we chose the
splitter $S$ to deliver the input value to the three modules in a
specified order, we have%

$$
S \eqdef \inp{mi}(x). \out{mi}_1(x).
                          \out{mi}_2(x).
                          \out{mi}_3(x).\inp{ack}.S
$$%

Note that a splitter delivering the input value in an arbitrary
order may be easily modelled. The voter:%

$$
V  \eqdef \inp{mo}(x_1). \inp{mo}(x_2).\inp{mo}(x_3).
(\ccsif{x_1 = x_2}{\out{mo}(x_1)}{\out{mo}(x_3)}).\out{ack}.V
$$%

The resulting fault tolerant version $P^{\#}_f$ of $P$, is its TMR
version where, for example, a single faulty module is inserted (see
also Figure~\ref{tmr:fig}).

\begin{figure}[t]
\centerline{\input{tmr.pstex_t}}
\caption{The flow diagram of the TMR version of $P$}
\protect{\label{tmr:fig}}
\end{figure}

\begin{eqnarray*}
\faultt{P_f} & \eqdef & (S \parallel P^{(1)} \parallel P^{(2)}
\parallel P^{(3)}_f \parallel V)
\setminus \{
            {\tt mi}_1,{\tt mi}_2, {\tt mi}_3, {\tt mo}_1,{\tt mo}_2,
            {\tt mo}_3, {\tt ack} \}
\end{eqnarray*}

The strategies illustrated in this paper, or a combination of them,
can be applied on $\faultt{P_f}$ to verify if it satisfy a property
expresses as an equational $\mu$-calculus formula $\varphi$. The
choise of the most suitable verification strategy usually depends on
the structure of the $\varphi$ and on the fault scenario against whom
to check it, as explained in Section~\ref{logicanalysis:sec}.

%  example
%%%%%%%%%%%%%%%%%%%%%%% 

\section{Conclusions}
This paper first shows how a fault tolerant (candidate) system may be
formalized using a process algebras (CCS).  The formal model is built
following a uniform modeling scheme requiring both the failing
behaviour (with respect to fault occurrences) and fault-recovering
procedures to be specified.  Faults are modeled as specific actions in
the system model, that a fault injector process is able to activate.
Fault tolerant properties are expressed as equational $\mu$-calculus
formulae.

This general framework makes a logical characterization of fault
tolerance possible. In fact the fault tolerant verification problem
(\wrt a property) can be stated as a module checking problem, that is
as the verification of an open system in an environment able to inject
any fault.

Moreover exploiting partial model checking strategies, the fault
tolerant verification problem (\wrt a formula) may be expressed as a
validity problem of a new formula obtained by partial evaluation of
the system model. In this way, general validation tools and proof
techniques can be exploited. For a more efficient (and tailored)
analysis we have proposed, for example, the use of universal and
conjunctive $\mu$-calculus formulas whose validity problem is easier
to be solved.  As a future work, we are developing a semi-automated
tool which, based on an existing partial model checker (\eg
see~\cite{nielsen}), would be able to perform the fault tolerant
analysis so far described.

\begin{thebibliography}{10}

\bibitem{IB-B941065} H.~R. Andersen.  \newblock {\em Verification of Temporal
    Properties of Concurrent Systems}.  \newblock PhD thesis, Department of
  Computer Science, Aarhus University, Denmark, 1993.

\bibitem{B97} G.~Bruns.
\newblock {\em Distributed System Analysis with CCS}.
\newblock Prentice Hall, 1997.

\bibitem{LICS::Andersen1995} H.~R. Andersen.  \newblock Partial model checking
  (extended abstract).  \newblock In {\em Proceedings of 10th Annual
  {IEEE} Symposium on Logic in Computer Science}, pages 398--407. IEEE
  Computer Society Press, 1995.

\bibitem{bekic} H.~Beki$\breve{{\rm c}}$.  \newblock Definable operations in
  general algebras, and the theory of automata and flow charts.  \newblock In
  C.B. Jones, editor, {\em Hans Beki$\breve{{\rm c}}$: Programming Languages
    and Their Definition}, volume 177 of {\em LNCS}, pages 30--55.
  Springer-Verlag, 1984.

\bibitem{BFG02:stvr} C.~Bernardeschi, A.~Fantechi, and S.~Gnesi.  \newblock
  Model checking fault tolerant systems.  \newblock {\em Software Testing,
    Verification and Reliability (STVR)}, 12(4):251--275, December 2002.

\bibitem{BS01} J.~Bradfield and C.~Stirling.  \newblock {\em Modal Logics and
    $\mu$-calculi: an introduction}, pages 293--332.  \newblock Handbook of
  Process Algebra. Elsevier, North-Holland, 2001.

\bibitem{emerson} {E.~A.~Emerson}.  \newblock {T}emporal and {M}odal {L}ogic.
  \newblock In {J.~van Leeuwen}, editor, {\em Handbook of Theoretical Computer
    Science}, volume~B, pages 996--1072, Amsterdam, 1990. Elsevier Science
  Publishers.

\bibitem{G99:acm} F.~C. Gartner.  \newblock Fundamentals of fault-tolerant
  distributed computing in asynchronous environments.  \newblock {\em ACM
    Computing Surveys}, 31(1):1--26, March 1999.

\bibitem{GPB02:ase} D.~Giannakopoulou, C.~S. Pasareanu, and H.~Barringer.
  \newblock Assumption generation for software component verification.
  \newblock In {\em 17th IEEE International Conference on Automated Software
    Engineering (ASE 2002), 23-27 September 2002, Edinburgh, Scotland, UK},
  pages 3--12. IEEE Computer Society, 2002.

\bibitem{HM85:acm} M.~Hennessy and R.~Milner.  \newblock Algebraic laws for
  non determinism and concurrency.  \newblock {\em Journal of the ACM},
  32:137--161, 1985.

\bibitem{kupf} T.~A.~Henzinger, O.~Kupferman, R.~Majumdar \newblock On the
  Universal and Existential Fragments of the mu-Calculus \newblock In Proc. of
  TACAS, pages 49-64, LNCS 2619, 2003.

\bibitem{Hoare85} C.~A.~R. Hoare.  \newblock {\em Communicating Sequential
    Processes}.  \newblock Prentice-Hall, Englewood Cliffs, NJ, 1985.

\bibitem{JW:autmcr} D.~Janin and I.~Walukiewicz.  \newblock Automata for the
  $\mu$-calculus and related results.  \newblock In J.~Wiedermann and
  P.~H{\'a}jek, editors, {\em Proceedings 20th Intl.\ Symp.\ on Mathematical
    Foundations of Computer Science, MFCS'95}, volume 969 of {\em LNCS}, 1995.

\bibitem{J98:nspw} E.~Jonsson.  \newblock An integrated framework for security
  and dependability.  \newblock In {\em Proceedings of the New Security
    Paradigms Workshop}, pages 22--25, Charlottesville, VA, USA, September
  1998.

\bibitem{L95} J.~C. Laprie.  \newblock Dependability: Basic concepts and
  terminology.  \newblock In J.~C. Laprie, editor, {\em Dependable Computing
    and Fault-Tolerant Systems}, volume~5. Springer-Verlag, 1995.

\bibitem{nielsen} J.~Lind-Nielsen.  \newblock Mudiv: A program performing
  partial model checking.  \newblock Master's thesis, Department of
  Information Technology, Technical University of Denmark, September 1996.

\bibitem{M98:csfw} F.~Martinelli.  \newblock Partial model checking and
  theorem proving for ensuring security properties.  \newblock In {\em
    Proc.~of the 11th IEEE Computer Security Foundation Workshop}, pages
  44--52. IEEE, Computer Society, 1998.

\bibitem{fabiosos} F.~Martinelli.  \newblock Analysis of security protocols as
  open systems.  \newblock TCS 290(1): 1057-1106 (2003)

\bibitem{MM98:csftsa} C.~Meadows and J.~McLean.  \newblock Security and
  dependability: Then and now.  \newblock In {\em Proc.~of Computer Security,
    Fault Tolerance, and Software Assurance: From Needs to Solutions -
    Workshop II}, Williamsburg, VA, November 1998.

\bibitem{M89} R.~Milner.  \newblock {\em Communication and Concurrency}.
  \newblock International Series in Computer Science. Prentice Hall, 1989.

\bibitem{Milner90} R.~Milner.  \newblock Operational and algebraic semantics
  of concurrent processes.  \newblock In J.~van Leewen, editor, {\em Handbook
    of Theoretical Computer Science}, volume B: Formal Models and Semantics,
  chapter~19, pages 1201--1242. The MIT Press, New York, N.Y., 1990.

\bibitem{milner:92a} R.~Milner, J.~Parrow, and D.~Walker.  \newblock A
  calculus of mobile processes.  \newblock {\em Information and Computation},
  100(1):1--77, 1992.

\bibitem{DV90:lncs} R.~De Nicola and F.~Vaandrager.  \newblock Action versus
  state based logics for transition systems.  \newblock In {\em Lecture Notes
    in Computer Science}, volume 469, pages 407--419. Springer-Verlag, 1990.

\bibitem{SWD99:ssd} A.~Simpson, J.~Woodcock, and J.~Davis.  \newblock Safety
  through security.  \newblock In IEEE Computer~Society Press, editor, {\em
    Proc.~of the 9th International Workshop on Software Specification and
    Design}, pages 18--24, Ise-Shima.~Japan, April 1999.

\bibitem{Street89} R.~S. Streett and E.~A. Emerson.  \newblock An automata
  theoretic procedure for the propositional $\mu-$calculus.  \newblock {\em
    Information and Computation}, 81(3):249--264, 1989.

\bibitem{TWM02:sac} H.~H. Thompson, J.~A. Whittaker, and F.~E. Mottay.
  \newblock Software security vulnerability testing in hostile environments.
  \newblock In ACM Press, editor, {\em Proceedings of the 2002 ACM symposium
    on Applied computing (SAC 02}, pages 260--264, Madrid, Spain, 2002.

\bibitem{LICS95*14} I.~Walukiewicz.  \newblock Completeness of {K}ozen's
  axiomatization of the propositional {$\lambda$}-calculus.  \newblock In {\em
    Symposium on Logic in Computer Science ({LICS} '95)}, pages 14--24, Los
  Alamitos, Ca., USA, 1995. IEEE Computer Society Press.

\end{thebibliography}

\end{document}
