%Formal verification is rapidly becoming a promising automated method to ensure the accuracy and correctness of software systems. We want to perform an "a priori" verification, so that probable bugs are discovered at design phase, before implementing a prototype in the next testing phase. This check, based on static analysis, allows to specify the correctness of a system and to analyze it systematically and exhaustively. More specifically, 

Model Checking techniques consist of estimating the compliance between the mathematical model of a system and a set of formal axioms representing correctness specifications. 

In what follows we assume the reader be familiar with the \ctl\ \cite{clar-grum-pele-99} formal language as well as with the \smv model checker \cite{smv92}.

The syntax of the formulas can be defined using Backus-Naur form. It is build by using propositional atoms as well as \ctl formulas. Any propositional logic formula is a \ctl formula and \ctl formulas may also contain path quantifiers followed by temporal operators. 

The semantics of the language is defined through a Kripke structure that defines a model for describing the semantics of a
temporal logic \cite{huth-ryan-99}.

%A Kripke model is the triple $(S,\rightarrow,L)$ where $S$ is a collection of states, $\rightarrow$ is a binary relation, describing that the system can move from state to state and, associated with each state $s$, the interpretation function $L$ provides the set of atomic propositions $L(s)$ which are true in that particular state .

The model checker we used in this approach is New Symbolic Model Verifier (NuSMV) \cite{smv92}, a tool for checking finite state systems against specifications expressed as \ctl formulas. The symbolic model checking approach of \smv allows to describe the transition relations of the model systems in a more compact way, \ie encode the transition relation as a Boolean function represented by an ordered Binary Decision Diagram.