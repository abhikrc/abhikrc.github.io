\section{Conclusions}
\stlabel{concl}

We have presented a technique for the push-button construction of a finite
abstract model of operational semantics, on the basis of a graph production
system consisting of a set of graph transformation rules. As pointed out in the
introduction, the contribution with respect to previous work is that this paper
works out the transformation itself and the ensuing abstract transition system
(Sections \ref{s:trans} and~\ref{s:example}): the shape model was presented
before. Given the fact that, as argued elsewhere (see, e.g.,
\cite{Corr+04,DepHecKue02,Dott+03,Kusk+02}), graph transformations are a very
suitable formalism to model the behaviour of software systems, especially in the
face of dynamic evolution, the results of this paper form an important step in
creating a practically feasible method for the verification of such systems.

\medskip\noindent\textit{Related work.}
%
In addition to the more or less related work mentioned above, there are some
lines of research that should be described in some more detail.

First and foremost among these is the work on shape graphs in
\cite{SagRepWil98,SagRepWil02}, already discussed in the introduction. As
remarked in Footnote~\ref{strength}, the analysis methods presented there are
superior in the sense that, for the purpose of sequential program analysis,
they yield more accurate predictions. For instance, through instrumentation it
is possible to tune the notion of ``shape'' to particular properties to be
checked, and the notion of 3-valued logic on the level of system assertions
makes it possible to state some ``negatives'' with certainty. The basic
contribution of this paper is that we develop essentially the same ideas
(though originating from another direction altogether, namely model checking)
in the context of the general, domain-independent formalism of graph
transformation. This means that, on the one hand, the results can be applied in
all those settings where graph production systems are being used for specifying
or modelling system behaviour (which include parallel and distributed systems,
and design-level semantic models, see above); and on the other hand,
long-standing results from graph transformation, for instance regarding rule
composition and independence, can be re-used in the context of abstraction.

More broadly speaking, our approach can be seen as an instance of abstract
interpretation, pioneered by Cousot and Cousot \cite{CouCou79}; see also
\cite{CouCou99} for a discussion of the use of abstract interpretation in model
checking. In terms of \cite{PolChaCor01}, our shapes form a distinctness
domain; however, in that terminology our abstract domain consists not of
individual shapes but of \emph{sets} of shapes (modulo isomorphism), and the
abstract ordering is set inclusion. We therefore do have a Galois connection;
but then, since we are not interested in computing fixpoints of computations
but rather in expressing temporal properties of behaviour, we do not currently
derive much benefit from this fact.

Another related area is the assertional approach for local reasoning on memory
structures developed in, e.g., separation logic \cite{OHeReyYan01,Reyn02}.
Here, too, an abstraction of a graph-based memory representation is taken as
the basic model upon which verification is carried out. Although the core
formalism is quite different in this case, one possible way to combine
strengths is to investigate assertional semantics for graph transformation
rules.

In the context of graph transformation, the closest related work is
\cite{BalKoeKoe03} on approximation of graph transition systems using
\emph{unfolding}, a technique that is generalised from Petri nets. Instead of
constructing individual states, an unfolding combines all states into a single
structure, in which transitions are modelled as purely local changes. Since
eventually such local changes tend to propagate to a global level, the
unfolding is \emph{cut off} after a certain number of steps, at which point an
over-approximation of the remaining behaviour is taken. Essentially, this
approach promises the same capabilities for generic and infinite-state system
verification as ours; once tool support for both is in place, a more detailed
comparison should prove very interesting.

\medskip\noindent\textit{Future work.}
%
There is a host of smaller and larger improvements to be made. 
%
\begin{itemize}
\item The current framework has a number of limitations in the graphs
  and transformation rules that are supported: graphs are deterministic,
  matchings have a dangling edge condition and have to be injective, and
  negative application conditions (cf.\ \cite{HabHecTae96}) are not allowed. We
  conjecture that all of these restrictions can be lifted to some degree, at
  the price of some complications in the theory. For instance, rather than
  forbidding transformations that would violate the determinism, as we
  currently do in the definition of concrete matchings, one could take the
  pushout in the category of deterministic graphs, which essentially means
  determinising the graph after transformation, i.e., recursively merging
  outgoing edges with the same label.
\item Graph transformations enjoy a very elegant algebraic characterisation
  (see, e.g., \cite{DPO}), which we have ignored in the current paper. In
  particular, our abstract shape transformation have no underlying notion of a
  morphism or span of morphisms; instead they are based on \emph{ad hoc}
  constructions. Consequently, there is no way to lift the results of this
  paper to other graph formalisms (for instance typed, attributed, or
  hypergraphs) or other types of abstraction without redoing the proofs.
\item The connection with the work on shape graphs, discussed above, can be
  exploited further by transferring more of the results achieved there to the
  setting of graph transformation. Prime candidate among these is the notion of
  abstraction refinement through instrumentation.
\end{itemize}
%
Notwithstanding the fact that there is ample room for improvement, the
constructions worked out in this paper are mature enough for implementation. We
plan to extend the tool GROOVE (see \cite{Rens03-agtive}), which has the
capability of generating concrete state spaces from graph production systems
for the purpose of model checking (see \cite{RenSchVar04}), with the necessary
functionality to deal with shapes. As a proof-of-concept, we have
``hand-crafted'' the examples presented in this paper into GROOVE production
rules mimicking the abstract behaviour.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "agt"
%%% End: 
