\section{Transitions}
\stlabel{example} 

In this section we pull together the results above, by defining
concrete (graph) transition systems and abstract (shape) transition systems and
stating their relation.

\begin{definition}[transition system]
Let $\Pi$ be a set of production rules. 
\begin{itemize}\smalltopsep\noitemsep
\item A \emph{graph transition} is a triple $G\trans P H$ with $G,H\in
  \DetGraph_\L$ and $P\in \Pi$ such that $G\trans{P,m} H$ for some $m$. A
  \emph{graph transition system} is a tuple $(\bG,{\trans~})$ where $\trans~$
  is the graph transition relation and $\bG\subseteq \DetGraph_\L$ is closed
  under $\trans~$ (i.e., $G\in \bG$ and $G\trans P H$ implies $H\in \bG$).
\item A \emph{shape transition} is a triple $S\trans P T$ with $S,T\in
  \Canon_\L$ and $P=(L,R)\in \Pi$ such that $\mat p S$ is consistent, $\mat p
  S\trans{P,\id_L} S'$ and $T\in \GCanon(S')$ for some pre-shaping $p\ftype L
  S$. A \emph{shape transition system} is a tuple $(\bS,{\trans~})$ where
  $\trans~$ is the shape transition relation and $\bS\subseteq \Canon_\L$ is
  closed under $\trans~$.% (i.e., $S\in \bS$ and $S\trans P T$ implies $T\in
%  \bS$).
\end{itemize}
\end{definition}
%
Given a set of production rules $\Pi$ and a graph $G\in \DetGraph$, we write
$\GTS(\Pi,G)$ for the smallest graph transition system including $G$; likewise,
given $S\in \Canon_\L$ we write $\STS(\Pi,S)$ for the smallest shape transition
system including $S$. For instance, \fref{buffer-ts} shows the graph transition
system $\GTS(\Pi,G)$ where $\Pi=\set{\Rput,\Rget}$ and $G$ is the graph of
\fref{init-buffer}. \fref{buffer-sts} shows $\STS(\Pi,\GCanon(G))$, where we
have used some notational conventions to represent multiplicities: thin arrows
and nodes are singular (node/incoming edge multiplicity $\meq1$) whereas fat
ones are multiple ($\mgt1$). The arrows in \fref{buffer-sts}
indicate $\Rput$-applications; for each arrow there is an implicit
$\Rget$-application in the reverse direction. The darker (shaded) area is the
fragment of the state space that actually is the image of the concrete
transition system.

\psfig[width=.9\textheight,angle=90]{buffer-sts}{Abstract buffer transition system}%
%
We now come to the main result, which states that the abstraction defined by
$\GCanon$ is finite and conservative, and in a weak sense does not over-approximate.
%
\begin{theorem}\thlabel{transitions}
Let $\Pi$ be a set of production rules and $I\in \DetGraph$; let
$\GTS(\Pi,I)=(\bG,{\trans~})$ and $\STS(\Pi, \GCanon(I))=(\bS,{\trans~})$.
\begin{enumerate}\noitemsep\smalltopsep
\item $\GCanon(\bG) \subseteq \bS$ and $\bS$ is finite;
\item For all $G,H\in \bG$, $G\trans P H$ implies $\GCanon(G) \trans P
  \GCanon(H)$.
\item For all $S,T\in \bS$ such that $S\trans{P} T$, there are $G',H'\in
  \DetGraph$ such that $S=\GCanon(G')$ and $G'\trans{P} H'$.
\end{enumerate}
\end{theorem}
%
This theorem implies that we can verify safety properties, where the
propositions are graph predicates in the fragment of first-order logic that is
reflected by our abstraction --- characterised in \cite{Rens04-esop} as a
fragment of 2-variable logic. Typical examples of such properties are
\emph{state invariants}, such as:
%
\begin{itemize}\noitemsep
\item The buffer is either empty (i.e., no cell reachable from the first
  contains an object), or the first cell contains an object;
\item If the buffer is empty, then the last cell is the predecessor of the first;
\item If a cell contains an object, either it is the last or the next also 
  contains an object.
\end{itemize}
%
Examples of valid properties that can \emph{not} be verified, i.e., that appear
to be violated on the abstract level but are in fact true in the concrete
system (so-called ``false negatives'') are:
%
\begin{itemize}\noitemsep
\item All cells of the circular buffer are connected;
\item $\Rput$ can only be executed infinitely often if $\Rget$ is also done
  infinitely often;
\item Objects are removed in the order they were inserted.
\end{itemize}

\medskip\noindent\textit{List reversal.}
%
\renewcommand{\snip}[1]{\textsf{\small{#1}}}%
To enable a better comparison with existing approaches, the remainder of this
section is devoted to an example that has been used several times before in
heap structure analysis; see, e.g.,
\cite{SagRepWil98,Reyn02}.\footnote{\label{strength}Note, however, that we
present this only for the sake of comparison and \emph{not} because we consider
this kind of sequential program analysis to be the strength of our method; the
approaches in \emph{op.\ cit.} are superior here. See also \stref{concl}.} 

\lstset{
    keywords={while,do,od,nil},
    numberstyle=\small,
    numbers=left,
    keepspaces=true,
    frame=tblr,
    columns=flexible,
    flexiblecolumns=true,
    basicstyle=\small\sffamily
}
\begin{wrapfigure}[6]{l}{3cm}\vspace*{-1.3\baselineskip}
\begin{lstlisting}[linewidth=4.5cm]{}
while (a.head != nil) do
    Cell tmp := b.head;
    b.head := a.head; 
    a.head := a.head.next;
    b.head.next := tmp;
od
\end{lstlisting}%\vspace*{-.9\baselineskip}
\end{wrapfigure}

\medskip
The program uses a data structure consisting of \snip{List}-nodes pointing via
a \headL-edge to a list of \snip{Cell}-nodes linked by \snip{next}-edges; there
is a unique \snip{nil}-node modelling the end of the list.
%
\psfig[scale=.8]{list-rule-new}{
    Small-step transformation rules for the list reversal program.
}%
%
%=====================================
% NEW PART
%=====================================
\fref{list-rule-new} shows a straightforward, line-by-line translation of this
program into graph transformation rules. The variables and fields are
represented by edges and their values by nodes. There is a central,
\snip{E}-labelled node that stands for the run-time environment, to which the
local variable edges are attached and which maintains a \snip{pc}-labelled
``program counter'' edge. Line~5 needs two rules, to distinguish the case where
\snip{b.head.next} already equals \snip{tmp} (which may occur if the list \snip
a originally has only a single element); this is because our matchings are
required to be injective (see \dref{rule}). We can now use standard graph
transformation results to combine these rules into ``large-step'' ones that
describe the combined effect of the loop body. The two resulting rules are
shown in \fref{List-rule2} (omitting the program counter, which now always
equals \snip 1).
%
\psfig[scale=.72]{List-rule2}{
    Large-step rules for the list reversal program.
}%
%

%% However, for the sake of simplicity and for space limitations we
%% consider the rule $\r{swap}$ of \fref{List-rule2}, which atomically performs
%% all the pointer updates involved in one execution of the while-loop body.  
%% The
%% rule $\r{one}$ deals instead with the special case of a list containing only
%% one single element.  Since the swapping is atomic, in these rules there is no
%% need of the temporary variable {\tt tmp}.

We show in \fref{trsys} the complete transition system generated by the
large-step rule $\r{swap}$ ($\r{single}$ is never enabled from the chosen start
state). The transition system is smaller than the one we would get
from the small-step rules (see, e.g., \cite{SagRepWil98}): the graph
transformation theory has paid off here. The possible runs of the transition
system all terminate in $S_7$, which represents the reversed list, now pointed
to by \snip b, whereas \snip a is empty.  An example property verifiable in the
transition system that the two lists are always kept separate: no $\snip{Cell}$
node is ever shared.
%
\psfig[scale=.55]{trsys}{Abstract transition system of the list reversal program.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "agt"
%%% End: 