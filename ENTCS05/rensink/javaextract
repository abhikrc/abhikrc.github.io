#!/bin/sh
# Usage: javaextract -incl SRC_FILES
#    or: javaextract SRC_FILE TGT_FILE
#
# extract works with so-called *extraction patterns*, which consist of
# comments of the form
#
# //B{pattern}
# //E{pattern}
# //I{pattern} text
#
# Usage 1: javaextract -incl SRC_FILES
# 
# After decomposing each FILE in SRC_FILES into DIR/FILENAME.EXT,
# javaextract creates files DIR/pattern.incl for each pattern thus
# encountered, plus DIR/FILENAME.incl for the entire file even if
# there isn't any pattern comment for it. html tags are stripped.
#
# Usage 2: javaextract SRC_FILE TGT_FILE
#
# Only the pattern FILENAME is used, and the result is written
# to TGT_FILE
#
# The target contains all text from FILE except that before the
# first //B{pattern}, between each //E{pattern} and the succeding 
# //B{pattern}, and after the last //E{pattern}. Moreover, any
# comments "//I{pattern} text" in the included range are uncommented
# (so just "text" is left). All //[BEI]{anypattern} are discarded.
#
# For example, a file "myfile" containing
#
#   text before (not in first pattern)
#   //B{first}
#   some more text
#   //I{first} first pattern only
#   //I{second} second pattern only
#   and then some
#   //E{second}
#   this is dropped in second pattern
#   //E{first}
#   and this in both patterns
#   //B{second}
#   final lines
#
# gives rise to three extracted files:
#
# - myfile.incl, containing
#
#   text before (not in first pattern)
#   some more text
#   and then some
#   this is dropped in second pattern
#   and this in both patterns
#   final lines
#
# - first.incl, containing
#
#   some more text
#   first pattern only
#   and then some
#   this is dropped in second pattern
#
# - second.incl, containing
#
#   text before (not in first pattern)
#   some more text
#   second pattern only
#   and then some
#   final lines
#

# Announce usage error and exit
usageError() {
    echo Usage: javaextract -incl SRC_FILES
    echo    or: javaextract SRC_FILE TGT_FILE
    exit 1;
}

if [ "X$1" = 'X-incl' ]
then # Usage 1: javaextract -incl SRC_FILES
     if [ "X$2" = "X" ]
     then usageError;
     fi;
else # Usage 2: javaextract SRC_FILE TGT_FILE
     if [ "X$1" = "X" ] || [ "X$2" = "X" ]
     then usageError;
     fi;
fi

# extracts contents from file, as indicated by pattern
# $1: name of the source file
# $2: pattern name
extractPattern() {
  BEGPAT="//B{$2}"
  ENDPAT="//E{$2}"
  INCPAT="//I{$2}\ *"
  ( if [ -z ""`cat $1 | sed "1,\|$ENDPAT|!d" | grep $BEGPAT` ];
    then # implicit begin of pattern
         echo $BEGPAT;
    fi
    cat $1;
  ) | \
  sed "\|$BEGPAT|,\|$ENDPAT|!d" | \
  sed "s|$INCPAT||" | \
  sed "\|//[IBE]{.*}|d"
}

# decomposes filename into DIR and FILENAME
# $1: filename to be decomposed
parseFilename() {
    if [ -n `echo $1 | sed 's|[^/]||g'`"" ]
    then # FILE = DIR/FILENAME.EXT
         DIR=`echo $1 | sed 's|\(.*\)/[^/]*|\1|'`;
         FILENAME=`echo $1 | sed 's|.*/\([^/]*\)\.[^\.]*|\1|'`
    else # FILE = FILENAME.EXT, DIR = .
         DIR='.'
         FILENAME=`echo $1 | sed 's|\([^/]*\)\.[^\.]*|\1|'`
    fi
}

# filter out certain HTML tags
filterHtmlTags() {
    sed "s|</*code>||g" |
    sed "s|</*tt>||g"   |
    sed "s|</*br>||g"   |
    sed "s|</*ul>||g"   |
    sed "s|</*li>||g"
}

if [ "X$1" = 'X-incl' ]
then # Usage 1: javaextract -incl SRC_FILES
    shift;
    for FILE in $@;
    do  parseFilename $FILE
        PATTERNS=`( ( grep "//[BEI]{.*}" $FILE |
                       sed 's|^.*//[BEI]{\([^}]*\)}.*$|\1|' 
                     );
                     echo $FILENAME
                   ) |
                   sort |
                   uniq`;
        for PATTERN in $PATTERNS;
        do  extractPattern $FILE $PATTERN | filterHtmlTags > ${DIR}/${PATTERN}.incl;
        done;
    done;
else # Usage 2: javaextract SRC_FILE TGT_FILE
    parseFilename $1;
    extractPattern $1 $FILENAME > $2;
fi
