\documentclass{entcs}
\usepackage{entcsmacro}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{graphicx}
%\input pdfcolor.tex 
\newcommand*{\bisim}{\mathbin{\mathop{\sim}\limits^{\texttt{.}}}}
\newcommand*{\todefout}{\mathbin{\mathop{\longrightarrow}\limits^{\overline{m}\langle N\rangle}}}
\newcommand*{\todefnout}{\mathbin{\mathop{\longrightarrow}\limits^{\overline{m}\langle n\rangle}}}
\newcommand*{\todefbout}{\mathbin{\mathop{\longrightarrow}\limits^{(\nu~\!n_1,\ldots,\nu~\!n_k)\overline{m}\langle N\rangle}}}
\newcommand*{\todefoutpi}{\mathbin{\mathop{\longrightarrow}\limits^{\overline{x}\langle y\rangle}}}
\newcommand*{\todefoutbpi}{\mathbin{\mathop{\longrightarrow}\limits^{\overline{x}{(}y{)}}}}
\newcommand*{\todefinpi}{\mathbin{\mathop{\longrightarrow}\limits^{x(y)}}}
\newcommand*{\todefinzpi}{\mathbin{\mathop{\longrightarrow}\limits^{x(z)}}}
\newcommand*{\todeftaupi}{\mathbin{\mathop{\longrightarrow}\limits^{\tau}}}
\newcommand*{\todefpipi}{\mathbin{\mathop{\longrightarrow}\limits^{\pi}}}
\newcommand*{\todefin}{\mathbin{\mathop{\longrightarrow}\limits^{m(x)}}}
\newcommand*{\todeftau}{\mathbin{\mathop{\longrightarrow}\limits^{\tau}}}
\newcommand*{\todefspi}{\mathbin{\mathop{\longrightarrow}\limits^{s\pi}}}
\newcommand*{\eqdef}{\mathbin{\mathop{=}\limits^{\texttt{def}}}}
\newcommand{\figrule}{\hrule}
\newcommand{\match}[3]{[#1~=~#2]~#3}
\newcommand{\order}[3]{[#1~{\succcurlyeq}~#2]~#3}
\newcommand{\orderst}[3]{[#1~{\succ}~#2]~#3}
\newcommand{\letsrvalue}[3]{{\bf let}~#1 = {\bf \mathcal{S}value}(#2)~{\bf in}~#3}
\newcommand{\out}[2]{\overline{#1}\langle #2 \rangle}
\newcommand{\inn}[2]{#1(#2)}
\newcommand{\fn}[1]{{\bf fn}(#1)}
\newcommand{\creduction}[1]{\stackrel{#1}{\longrightarrow}}
\newcommand{\transition}[1]{\stackrel{#1}{\longrightarrow}}
\newif\iflong
\longfalse 
\def\lastname{Aziz}
\begin{document}
\bibliographystyle{plain}
\begin{frontmatter}
\title{A Semiring-based Quantitative Analysis of Mobile Systems}
\author{Benjamin Aziz\thanksref{baziz@doc.ic.ac.uk}},
\address{Department of Computing\\Imperial College London\\180 Queen’s Gate\\ London SW7 2AZ, UK}
\thanks[baziz@doc.ic.ac.uk]{Email:
    \href{mailto:baziz@doc.ic.ac.uk}{\texttt{\normalshape
        baziz@doc.ic.ac.uk}}}
\begin{abstract}
We present in this paper, semi-$\pi$, an extension of the $\pi$-calculus that allows processes to query quantitative values of different actions and decide based on those values, whether an action is feasible or not. Our measure of quantity is based on the general notion of semirings.  Furthermore, we develop a syntax-directed static analysis for the new language, which captures the properties of name substitution and semiring value retrieval. Such properties allow us to solve quantitative constraints controlling synchronisations in the analysed systems. We provide an example of a cost analysis of communications in a simple adaptive routing algorithm.
\end{abstract}
\begin{keyword}
Static Analysis, Quantitative Resources, Semirings, Mobile Systems
\end{keyword}
\end{frontmatter}
\section{Introduction}\label{sect:introduction}
%\newtheorem{defin}{Definition}
In this paper, we present a syntax-directed static analysis of an extension of the $\pi$-calculus \cite{milner1} with semiring value retrieval capabilities and semiring constraints.  The new language, termed \textit{semi-$\pi$}, allows processes to query the cost of communicating actions given certain information.  Based on that cost, a process can then decide through the use of semiring constraints, the kind of behaviour it should perform next.  For example, in the process,\newline

\noindent
$\letsrvalue{\omega_1}{\overline{x}\langle y\rangle,t}{\letsrvalue{\omega_2}{\overline{u}\langle y\rangle,t}{}}$\newline
$\order{\omega_1}{\omega_2}{\overline{x}\langle y\rangle}\mid\order{\omega_2}{\omega_1}{\overline{u}\langle y\rangle}$\newline

\noindent
Then after retrieving the cost of actions, $\overline{x}\langle y\rangle$ and $\overline{u}\langle y\rangle$ at time, $t$, using the $\letsrvalue{}{}{}$ and placing the results in $\omega_1,\omega_2$, we compare the two costs using some ordering relation, $\succcurlyeq$, and choose either output.

The static analysis then captures two properties of the analysed systems: The first is name substitutions, which occur as a result of synchronising actions, the second is instantiations of actions' costs, given certain context information. Using these properties, it is possible to quantify name substitutions based on the cost of actions that contributed to those substitutions.  Such properties have interesting applications in the analysis of adaptive network routing, where a router calculates the output port of each packet based on the cost of the different paths of its neighbours.

Our measure of cost is based on the notion of \textit{semirings}. A semiring is a tuple, $(\mathcal{A},+,\times,1,0)$, such that $\mathcal{A}$ is a set and $0,1\in\mathcal{A}$.  Furthermore, $+$ is the additive operation, which is commutative and associative, with $0$ as its unit element, and $\times$ is the multiplicative operation, which is associative, with $1$ as its unit element and $0$ as its absorbing element.  A semiring has the property that $\times$ distributes over $+$.  Moreover, following \cite{bistarelli2}, it is possible to define an ordering relation based on $+$:
\[s\succcurlyeq s'~~\Leftrightarrow~~s+s'=s\]
where we sometimes write $s\succ s'$ to mean $s\succcurlyeq s'$ and $s\ne s'$.  This measure of cost is general: there exist many instantiations of $(\mathcal{A},+,\times,1,0)$ in literature that are Boolean, probabilistic, fuzzy, set-theoretic, weighted etc.

The rest of the paper is organised as follows.  In Section \ref{sect:related}, we discuss some of the related work in the area of quantitative analysis of mobile systems. In Section \ref{sect:spikyplus}, we introduce the syntax of the semi-$\pi$ language.  In Section \ref{sect:domain}, we define a domain-theoretic model as the basis of the standard semantics of semi-$\pi$.  In Section \ref{sect:nonstandard}, we extend this semantics to capture name substitutions and instantiations of semiring variables.  In Section \ref{sect:abstract}, we abstract the non-standard semantics in order to obtain a computable static analysis. In Section \ref{sect:qanalysis}, we demonstrate how the results of the abstract semantics yield a solution to a constraint satisfaction problem involving the relationship between name substitutions and costs of actions. In Section \ref{sect:example}, we apply the analysis to a simple example of an adaptive router.  Finally, in Section \ref{sect:conclusion}, we conclude the paper and discuss future work.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}\label{sect:related}
The work presented in this paper is a continuation of previous analyses \cite{aziz3,aziz7,aziz2,aziz5}, which were designed to detect security properties based on the name substitution property in mobile and cryptographic/PKI systems modelled in different versions of the $\pi$-calculus (e.g. the spi calculus \cite{abadi1b} and Spiky \cite{gray1}).  The main novelty of the current work is that the analysis deals with quantitative properties (e.g. cost of name substitutions) rather than qualitative properties (e.g. security properties).

Other works in the area of quantitative analysis of mobile systems include \cite{brodo1,buchholz1,hirsch1,priami3}, in the area of the quantitative analysis of process algebraic models have been carried out, using different approaches.  Most of such works differ from our approach in that a process has no ``quantitative control'' over its future execution, as is the case with semi-$\pi$.  Other quantitative analyses exist \cite{pierro2,pierro1} but these are usually designed for simpler, KLAIM-like, languages without name-passing.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semi-$\pi$}\label{sect:spikyplus}
The syntax of the semi-$\pi$ language is defined in Figure \ref{fig:syntax}.
\begin{figure*}[!bht]
\begin{footnotesize}
\figrule
\begin{tabular}{lcl}
$P,Q,R ::=$                            & $~~~~~$ &   processes\\
$~~~~\pi.P $                    & $~~~~~$ & guards                                      \\
$~~~~P~|~Q$                            & $~~~~~$ & composition                                 \\
$~~~~(\nu n)P$                       & $~~~~~$ & restriction\\
$~~~~!P$                               & $~~~~~$ & replication                                 \\
$~~~~\match{x}{y}{P}$                  & $~~~~~$ & match                                       \\
$~~~~\order{e_1}{e_2}{P}$                & $~~~~~$ & semiring constraint                                       \\
$~~~~{\bf 0}$                          & $~~~~~$ & null                                         \\
$~~~~\letsrvalue{\omega}{\pi,n}{P}$                 & $~~~~~$ & semiring value retrieval\\
&&\\
$\pi ::=$                            & $~~~~~$ &   guards\\
$~~~~\out{x}{y}$                 & $~~~~~$ & output\\
$~~~~\inn{x}{y}$                & $~~~~~$ &input \\
&&\\
$e::=$                            & $~~~~~$ &   expressions\\
$~~~~\omega$                 & $~~~~~$ & semiring variable\\
$~~~~s$                 & $~~~~~$ & semiring element\\
$~~~~e_1+e_2$                & $~~~~~$ &additive operation \\
$~~~~e_1\times e_2$                & $~~~~~$ &multiplicative operation \\
&&\\
$E,F::=$                            & $~~~~~$ &  systems                                           \\
$~~~~(\theta,P)$                             & $~~~~~$ & state-process pair\\
\end{tabular}
\figrule
\end{footnotesize}
\caption{The syntax of the semi-$\pi$ language}\label{fig:syntax}
\end{figure*}
In this syntax, names constitute the infinite set, $a,b,c,n,m,x,y,z\ldots\in\mathcal{N}$.  Processes, $P,Q,R\in\mathcal{P}$, are defined as follows.  A guarded process, $\pi.P$, proceeds as $P$ once it fires $\pi$, where $\pi$ is either input, $\inn{x}{y}$ or output, $\out{x}{y}$.  In case of $\inn{x}{y}$, the message received over $x$ will replace $y$ in $P$.  Parallel composition, $P~|~Q$ runs $P$ and $Q$ by interleaving them.  Restriction, $(\nu n)P$, creates a fresh name, $n$, within the scope of $P$.  Replication, $!P$, spawns as many copies of $P$ as required by the context. Matching, $\match{x}{y}{P}$, proceeds as $P$ if $x$ is the same as $y$, else it blocks.  Similarly, the semiring constraint, $\order{e_1}{e_2}{P}$, proceeds as $P$ if $e_1\succcurlyeq e_2$, otherwise, it blocks.  Expressions, $e_1,e_2$, are defined using semiring variables, $\omega\in\Omega$, elements $s\in\mathcal{A}$, applications of the additive operator, $e_1+e_2$, and applications of the multiplicative operator, $e_1\times e_2$.  The null process, ${\bf 0}$, is a process incapable of evolving any further.  We usually omit trailing null residues.  Finally, $\letsrvalue{\omega}{\pi,n}{P}$ retrieves the semiring value of an action, $\pi$, given some name, $n$, and instantiates $\omega$ with that value in $P$.  Intuitively, $n$ acts as a context data that may be needed in order to give more specific information about the action $\pi$ (e.g. time of the action, relative position of the action, the name of the user performing the action etc.).

Based on this definition of processes, we define systems, $E,F\in\mathcal{E}$, as pairs, $(\theta,P)$, where $\theta(\pi,n)=s_{\pi,n}\in\mathcal{A}$ is a state environment mapping every communication action, $\pi$, and its context data, $n\in\mathcal{N}$, to some corresponding semiring value, $s_{\pi,n}\in\mathcal{A}$.  The value, $s_{\pi,n}$, in effect represents a \textit{quantification of action $\pi$ in light of the information given by $n$}.

The standard notions of $\alpha$-conversion as well as the free names, $\textit{fn}(P)$, and bound names, $\textit{bn}(P)$, of a process, $P$, are defined as usual, where $y$ is bound to $P$ in $(\nu y)P$ and $\inn{x}{y}.P$.  A name is free if it is not bound.  Furthermore, we refer to $\textit{bsemiv}(P)$ as the set of bound semiring variables of $P$, i.e. $\omega$ in the $\letsrvalue{\omega}{\pi,n}{P}$ process, and $\textit{fsemiv}(P)$ as the set of free semiring variables, i.e. variables occurring in expressions but not in $\textit{bsemiv}(P)$.  We usually write $\textit{semiv}(P)=\textit{fsemiv}(P)\cup\textit{bsemiv}(P)$.  From now on, we only deal with systems that have a \textit{normal process}.
\begin{definition}\label{def:normal}
A process, $P$, is said to be \textit{normal} if the following holds:
\begin{itemize}
\item
There are no occurrences of homonymous bound names or homonymous semiring variables in $P$.
\item
$\textit{bn}(P)\cap\textit{fn}(P)=\{\}$.
\item
$\textit{fsemiv}(P)=\{\}$ (no open expressions).
\end{itemize}
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Domain-Theoretic Model}\label{sect:domain}
The standard semantics of semi-$\pi$ is defined in the domain-theoretic style of \cite{aziz1,aziz2,stark1}. Assuming that $Pi_\bot$ is the semantic domain of processes, $N$ is the predomain of names and $\mathcal{K}$ is the set underlying any (pre)domain, then concrete elements of $Pi_\bot$ and $N$ can be defined as in Figure \ref{fig:simplepi}.
\begin{figure}[bht]
\begin{footnotesize}
\figrule
$\begin{array}{lll}
\mbox{{\itshape Elements of\/} }N:&&\\
x\in\mathcal{N}&~\Rightarrow~&x\in\mathcal{K}(N)\\
\mbox{{\itshape Elements of\/} }Pi_\bot:&&\\
\{\!|\bot|\!\}\in\mathcal{K}(Pi_\bot)&&\\
\emptyset\in\mathcal{K}(Pi_\bot)&&\\
p,q\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&p\uplus q\in\mathcal{K}(Pi_\bot)\\
x\in\mathcal{K}(N),p\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&\mbox{{\itshape new}}(x,p)\in\mathcal{K}(Pi_\bot)\\
p\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&\{\!|\mbox{{\itshape tau}}(p)|\!\}\in\mathcal{K}(Pi_\bot)\\
x,y\in\mathcal{K}(N), p\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&\{\!|\mbox{{\itshape in}}(x,\lambda y.p)|\!\}\in\mathcal{K}(Pi_\bot)\\
x,y\in\mathcal{K}(N), p\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&\{\!|\mbox{{\itshape out}}(x,y,p)|\!\}\in\mathcal{K}(Pi_\bot)\\
x,y\in\mathcal{K}(N), p\in\mathcal{K}(Pi_\bot)&~\Rightarrow~&\{\!|\mbox{{\itshape out}}(x,\lambda y.p)|\!\}\in\mathcal{K}(Pi_\bot)\\
\end{array}$
\figrule
\end{footnotesize}
\caption{Elements of $Pi_\bot$ and $N$.\label{fig:simplepi}}
\end{figure}

The definition of $N$ is trivial: $N$ is a flat predomain\footnote{A domain with no bottom where every two non-identifiable elements are non-comparable.}.  Therefore, it's structure is quite similar to $\mathcal{N}$.  On the other hand, $Pi_\bot$ is defined as a multiset of semantic elements, where $\{\!|\bot|\!\}$ is the bottom element representing the undefined process and $\emptyset$ is the empty multiset representing terminated or deadlocked processes\footnote{$\{\!|\bot|\!\}\sqsubseteq\emptyset$ and $\emptyset$ is incomparable otherwise.}.  Other elements are defined as follows: $p\uplus q$ is the standard multiset union of two elements, $p,q$.  The singleton map, $\{\!|~|\!\}$, takes tuples representing input, output and silent actions and creates a singleton multiset of each tuple.  These tuples are $\textit{in}(x,\lambda y.p)$ (input action), $\textit{out}(x,y,p)$ (free output action), $\textit{out}(x,\lambda y.p)$ (bound output action) and $\textit{tau}(p)$ (silent action). In these tuples, $x$ is the channel of communication, $y$ is the message or input parameter and $p$ is the residue process. The use of $\lambda$-abstraction to model the binding effect in input and bound output actions implies that these actions have a meaning as a function, which when instantiated with a name, the actual residue is yielded.  Finally, the effects of restriction are modelled by the \textit{new} operator defined over elements $p\in Pi_\bot$ as in Figure \ref{fig:newpi}.
\begin{figure}[bht]
\begin{footnotesize}
\figrule
$\begin{array}{lll}
\mbox{{\itshape new\/}}(x,\emptyset)&=&\emptyset\\
\mbox{{\itshape new\/}}(x,\{\!|\bot|\!\})&=&\{\!|\bot|\!\}\\
\mbox{{\itshape new\/}}(x,\{\!|in(y,\lambda z.p)|\!\})&=&
\left\{\begin{array}{ll}
\emptyset,&\mbox{if }x=y\\
\{\!|in(y,\lambda z.\mbox{{\itshape new\/}}(x,p))|\!\},&\mbox{otherwise}\\
\end{array}\right.\\
\mbox{{\itshape new\/}}(x,\{\!|out(y,z,p)|\!\})&=&
\left\{\begin{array}{ll}
\emptyset,&\mbox{if }x=y\\
\{\!|out(y,\lambda z.p)|\!\},&\mbox{if }x=z\neq y\\
\{\!|out(y,z,\mbox{{\itshape new\/}}(x,p))|\!\},&\mbox{otherwise}
\end{array}\right.\\
\mbox{{\itshape new\/}}(x,\{\!|out(y,\lambda z.p)|\!\})&=&
\left\{\begin{array}{ll}
\emptyset,&\mbox{if }x=y\\
\{\!|out(y,\lambda z.\mbox{{\itshape new\/}}(x,p))|\!\},&\mbox{otherwise}\\
\end{array}\right.\\
\mbox{{\itshape new\/}}(x,\{\!|\mbox{{\itshape tau\/}}(p)|\!\})&=&\{\!|\mbox{{\itshape tau\/}}(\mbox{{\itshape new\/}}(x,p))|\!\}\\
\mbox{{\itshape new\/}}(x,(p_1\uplus p_2))&=&\mbox{{\itshape new\/}}(x,p_1)~\uplus~\mbox{{\itshape new\/}}(x,p_2)\\
\end{array}$
\figrule
\end{footnotesize}
\caption{The definition of {\itshape new\/}.\label{fig:newpi}}
\end{figure}

In general, {\itshape new\/} captures deadlocked situations arising from the attempt to communicate over restricted non-extruded channels.  It also turns a free output into a bound output once a restricted message is directly sent over a channel (scope extrusion).  In all other cases, restriction has no effect and it is simply passed to the residue or distributed over multiset union.

Using elements $p\in Pi_\bot$, it is possible to denote the meaning of systems in semi-$\pi$, with the semantic function, $\mathcal{S}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}\in Pi_\bot$, defined by induction over the structure of $P$ as in Figure \ref{fig:semanticspi}.  Since $\theta$ remains constant throughout the interpretation, it is sufficient to interpret a system in terms of elements of $Pi_\bot$.
\begin{figure}[bht]
\begin{footnotesize}
\figrule
$\begin{array}{llll}
(\mathcal{S} 1)&\mathcal{S}(\![(\theta,{\bf 0})]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\emptyset\\
(\mathcal{S} 2)&\mathcal{S}(\![(\theta,x(y).P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\{\!|\mbox{{\itshape in\/}}(\phi_\mathcal{S}(x),\lambda y.\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S})|\!\}\\
(\mathcal{S} 3)&\mathcal{S}(\![(\theta,\overline{x}\langle y\rangle.P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\\
&\multicolumn{3}{l}{(\underset{(\theta,x'(z).P')\in\rho}{\biguplus}\{\!|\mbox{{\itshape tau\/}}(p)|\!\}~)~\uplus~\{\!|\mbox{{\itshape out\/}}(\phi_\mathcal{S}(x),\phi_\mathcal{S}(y),{\mathcal R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S})|\!\}}\\
&\multicolumn{3}{l}{\mbox{where, }p=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho[(\theta,P')/(\theta,x'(z).P')]]\!)~\phi_\mathcal{S}[z\mapsto\phi_\mathcal{S}(y)]~\delta_\mathcal{S}}\\
&\multicolumn{3}{l}{\mbox{and, }\phi_\mathcal{S}(x)=\phi_\mathcal{S}(x')}\\
(\mathcal{S} 4)&\multicolumn{3}{l}{\mathcal{S}(\![(\theta,\match{x}{y}{P})]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}=\left\{\begin{array}{ll}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S},&\mbox{if }\phi_\mathcal{S}(x)=\phi_\mathcal{S}(y)\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S},&\mbox{otherwise}\end{array}\right.}\\
(\mathcal{S} 5)&\multicolumn{3}{l}{\mathcal{S}(\![(\theta,\order{e_1}{e_2}{P})]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}=}\\
&\multicolumn{3}{l}{\left\{\begin{array}{l}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S},\mbox{ if }e_1[\delta_\mathcal{S}(\omega_1)/\omega_1]_{\omega_1\in\textit{semiv}(e_1)}\succcurlyeq e_2[\delta_\mathcal{S}(\omega_2)/\omega_2]_{\omega_2\in\textit{semiv}(e_2)}\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S},\mbox{ otherwise}\end{array}\right.}\\
(\mathcal{S} 6)&\mathcal{S}(\![(\theta,P\mid Q)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\{\!|(\theta,Q)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S}\\
(\mathcal{S} 7)&\mathcal{S}(\![(\theta,(\nu x)P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\mbox{{\itshape new\/}}(x,\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S})\\
(\mathcal{S} 8)&\multicolumn{3}{l}{\mathcal{S}(\![(\theta,\letsrvalue{\omega}{\pi,n}{P})]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S}[\omega\mapsto\theta(\pi,n)]}\\
(\mathcal{S} 9)&\mathcal{S}(\![(\theta,!P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\bigsqcup\mathcal{F}\\
&\multicolumn{3}{l}{\mbox{where, }\mathcal{F}=\{\{\!|\bot|\!\},}\\ &\multicolumn{3}{l}{\hfill\mathcal{R}(\![~(\underset{i=0\ldots\infty}{{\biguplus}}\{\!|(\theta,P[\mbox{{\itshape bn\/}}_i(P)/\mbox{{\itshape bn\/}}(P)][\mbox{{\itshape semiv\/}}_i(P)/\mbox{{\itshape semiv\/}}(P)])|\!\})~\uplus~\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S}\}}\\
&\multicolumn{3}{l}{\mbox{and, }\mbox{{\itshape bn\/}}_i(P)=\{x_i\mid x\in\mbox{{\itshape bn\/}}(P)\},\mbox{{\itshape semiv\/}}_i(P)=\{\omega_i\mid \omega\in\mbox{{\itshape semiv\/}}(P)\}}\\
(\mathcal{R} 0)&\mathcal{R}(\![\rho]\!)~\phi_\mathcal{S}~\delta_\mathcal{S}&=&\underset{(\theta,P)\in\rho}{\biguplus}\mathcal{S}(\![(\theta,P)]\!)~(\rho\backslash\{\!|(\theta,P)|\!\})~\phi_\mathcal{S}~\delta_\mathcal{S}\\
\end{array}$
\figrule
\end{footnotesize}
\caption{The standard semantics of semi-$\pi$.\label{fig:semanticspi}}
\end{figure}
This semantics introduces the following environments.
\begin{itemize}
\item
The multiset, $\rho$, containing all processes composed in parallel with the analysed process, paired with a copy of $\theta$.  The standard singleton, $\{\!|~|\!\}$, and multiset union, $\uplus$, operations are overloaded to deal with elements of $\rho$.
\item
The special environment, $\phi_\mathcal{S}:\mathcal{N}\to\mathcal{N}$, maps a name to another name that substitutes it in the semantics. Initially, $\forall n\in\mathcal{N}:\phi_{\mathcal{S}0}(n)=n$. In fact, this environment will hold substitutions of input parameters by messages received during communications.  Since the standard denotational semantics is a precise semantics, an input parameter can only be mapped to, at most, one name in any possible choice of control flow (i.e. on either side of $\uplus$).
\item
The special environment, $\delta_\mathcal{S}:\Omega\to\mathcal{A}_\bot$, which maps semiring variables to semiring values.  Initially, $\forall\omega\in\Omega:\delta_{\mathcal{S}0}(\omega)=\bot$ for any variable, $\omega$.
\end{itemize}

The meaning of the composed systems in $\rho$ is given by rule $(\mathcal{R} 0)$ as the summation of the individual meaning of each system. Rule $(\mathcal{S} 1)$ interprets the meaning of a null process directly as the empty multiset, $\emptyset$.  Rules $(\mathcal{S} 2)$ and $(\mathcal{S} 3)$ deal with the cases of processes guarded by input and output actions after which the residues are composed with elements of $\rho$.  Any communications between matching input/output actions are dealt with in rule $(\mathcal{S} 3)$, where $\phi_\mathcal{S}$ is updated accordingly.  The interpretation is a summation of all such communications and the no-communication case. This preserves the associativity property of the parallel composition operator, $P\mid Q$. Rule $(\mathcal{S} 4)$ interprets conditional statements based on matching the $\phi_\mathcal{S}$-values of two names.  Rule $(\mathcal{S} 5)$ interprets a semiring constraint based on the ordering relation, $\succcurlyeq$, after closing two expressions under the $\delta_\mathcal{S}$ environment. Rule $(\mathcal{S} 6)$ is straightforward allowing for two parallel processes to be composed with the rest of processes in $\rho$, where $\theta$ is distributed over the two processes.  Rule $(\mathcal{S} 7)$ interprets a restriction using the {\itshape new\/} operation, defined earlier in Figure \ref{fig:newpi}.  In rule $(\mathcal{S} 8)$, the meaning of semiring retrieval is given by updating $\delta_\mathcal{S}$ with the semiring value of an action, $\pi$, given a name, $n$.  Finally, rule $(\mathcal{S} 9)$ defines the least fixed point meaning of a replicated process, $!P$, as the least upper bound of the poset, $\mathcal{F}$, which contains the bottom element, $\{\!|\bot|\!\}$, and elements denoting any number (up to infinity) of parallel compositions of the replicated process, $P$. Since the semantic domain, $Pi_\bot$, is infinite, $\mathcal{F}$ may contain infinite number of elements, therefore, its least upper bound may not be computable within finite limits.  A labelling mechanism is also used in the rule to perform $\alpha$-conversion on the spawned copies, $P$, by subscripting all the bound names and semiring variables of $P$.  The renaming is necessary to maintain the normality of processes.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Non-standard Semantics}\label{sect:nonstandard}
Our main interest is to capture instantiations of input parameters and semiring variables.  Since the standard semantics of the previous section does not provide this information, we need to extend it.  For this purpose, we introduce the two special environments, $\phi_\mathcal{E}:N\to\wp(N)$ and $\delta_\mathcal{E}:\Omega\to\wp(\mathcal{A})$, mapping a name to a set of names and a semiring variable to a set of semiring values, respectively. Both of these mappings represent possible instantiations that may occur during runtime.  Initially, we have that $\forall n\in\mathcal{N}:\phi_{\mathcal{E}0}(n)=\{n\}$ and $\forall\omega\in\Omega:\delta_{\mathcal{E}0}(\omega)=\{\}$.  Since there are no homonymous occurrences of bound names and semiring variables (Definition \ref{def:normal}), then the sets $\phi_\mathcal{E}(y)$ and $\delta_\mathcal{S}(\omega)$ will be at most singletons per choice of control flow for any name, $y$, and semiring variable, $\omega$.

Using these environments, we can define the non-standard semantic domain, $D_\bot=Pi_\bot\times(N\to\wp(N))\times(\Omega\to\wp(\mathcal{A}))_\bot$, with the following ordering:\newline

\noindent $\forall (p_1,\phi_{\mathcal{E}1},\delta_{\mathcal{E}1}),(p_2,\phi_{\mathcal{E}2},\delta_{\mathcal{E}2})\in D_\bot:$\newline
$(p_1,\phi_{\mathcal{E}1},\delta_{\mathcal{E}1})\sqsubseteq_{D_\bot}(p_2,\phi_{\mathcal{E}2},\delta_{\mathcal{E}2})~~\Leftrightarrow~~p_1\sqsubseteq p_2~\wedge~\phi_{\mathcal{E}1}\subseteq\phi_{\mathcal{E}2}~\wedge~\delta_{\mathcal{E}1}\subseteq\delta_{\mathcal{E}2}$\newline

\noindent
where the bottom element is $\bot_{D_\bot}=(\{\!|\bot|\!\},\phi_{\mathcal{E}0},\delta_{\mathcal{E}0})$.  We also define the unions of $\phi_\mathcal{E}$ and $\delta_\mathcal{E}$ as follows:
\begin{eqnarray*}
(\phi_{\mathcal{E}1}\cup_\phi\phi_{\mathcal{E}2})(x)&=&~\phi_{\mathcal{E}1}(x)\cup\phi_{\mathcal{E}2}(x)\\
(\delta_{\mathcal{E}1}\cup_\delta\delta_{\mathcal{E}2})(\omega)&=&~\delta_{\mathcal{E}1}(\omega)\cup\delta_{\mathcal{E}2}(\omega)
\end{eqnarray*}
Now, we can define the non-standard semantics of semi-$\pi$ using the function, $\mathcal{E}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{E}~\delta_\mathcal{E}\in D_\bot$, as shown in Figure \ref{nonstandpi}.
\begin{figure}[bht]
\begin{footnotesize}
\figrule
$\begin{array}{llll}
(\mathcal{E} 1)&\mathcal{E}(\![(\theta,{\bf 0})]\!)~\rho~\phi_\mathcal{E}~\delta_\mathcal{E}&=&(\emptyset,\phi_\mathcal{E},\delta_\mathcal{E})\\
(\mathcal{E} 2)&\mathcal{E}(\![(\theta,x(y).P)]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&(\{\!|\mbox{{\itshape in\/}}(x',\lambda y.p')|\!\},\phi_\mathcal{E},{\delta_\mathcal{E}})\\
&&&\mbox{where, }(p',\phi'_\mathcal{E},{\delta_\mathcal{E}}')=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}\\
&&&\mbox{and, }\phi_\mathcal{E}(x)=\{x'\}\\
(\mathcal{E} 3)&\mathcal{E}(\![(\theta,\overline{x}\langle y\rangle.P)]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&((\underset{(\theta,x'(z).P')\in\rho}{\biguplus}\!\!\!\!\!\!\!\!\{\!|\mbox{{\itshape tau\/}}(p')|\!\})~\uplus~\{\!|\mbox{{\itshape out\/}}(x'',y'',p'')|\!\},\\
&\multicolumn{3}{l}{\hspace{42.5mm}(\underset{(\theta,x'(z).P')\in\rho}{\bigcup_\phi}\!\!\!\!\!\!\!\!\phi'_\mathcal{E})~\cup_\phi~\phi_\mathcal{E},(\underset{(\theta,x'(z).P')\in\rho}{\bigcup_\delta}\!\!\!\!\!\!\!\!\delta'_\mathcal{E})~\cup_\delta~\delta_\mathcal{E})}\\
&\multicolumn{3}{l}{\mbox{where, }(p',\phi'_\mathcal{E}, \delta'_\mathcal{E})=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho[(\theta,P')/(\theta,x'(z).P')]]\!)~\phi_\mathcal{E}[z\mapsto~\{y\}]~{\delta_\mathcal{E}},}\\
&\multicolumn{3}{l}{\hspace{11mm}(p'',\phi''_\mathcal{E},\delta''_\mathcal{E})=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}}\\
&\multicolumn{3}{l}{\mbox{and, }\phi_\mathcal{E}(x)=\phi_\mathcal{E}(x')=\{x''\}, \phi_\mathcal{E}(y)=\{y''\}}\\
(\mathcal{E} 4)&\multicolumn{3}{l}{\mathcal{E}(\![(\theta,\match{x}{y}{P})]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}=\left\{\begin{array}{l}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}},\mbox{ if }\exists z\in\phi_\mathcal{E}(x),z'\in\phi_\mathcal{E}(y):\\
\hfill z=z'\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}},\mbox{ otherwise }\\
\end{array}\right.}\\
(\mathcal{E} 5)&\multicolumn{3}{l}{\mathcal{E}(\![(\theta,\order{e_1}{e_2}{P})]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}=}\\
&\multicolumn{3}{l}{\left\{\begin{array}{l}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}},\mbox{ if }\exists e\in(\textit{fold}~Y_{\delta_\mathcal{E}}~\{e_1\}~\textit{semiv}(e_1)),\\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e'\in(\textit{fold}~Y_{\delta_\mathcal{E}}~\{e_2\}~\textit{semiv}(e_2)):e\succcurlyeq e'\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}},\mbox{ otherwise}\\
\end{array}\right.}\\
(\mathcal{E} 6)&\mathcal{E}(\![(\theta,P\mid Q)]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\{\!|(\theta,Q)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}\\
(\mathcal{E} 7)&\mathcal{E}(\![(\theta,(\nu x)P)]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&(\mbox{{\itshape new\/}}(x,p'),\phi'_\mathcal{E},{\delta_\mathcal{E}}')\\
&&&\mbox{where, }(p',\phi'_\mathcal{E},{\delta_\mathcal{E}}')=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}\\
(\mathcal{E} 8)&\multicolumn{3}{l}{\mathcal{E}(\![(\theta,\letsrvalue{\omega}{\pi,n}{P})]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}[\omega\mapsto\{\theta(\pi,n)\}]}\\
(\mathcal{E}9)&\mathcal{E}(\![(\theta,!P)]\!)~\rho~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&\bigsqcup\mathcal{F}\\
&\multicolumn{3}{l}{\mbox{where, }\mathcal{F}=\{(\{\!|\bot|\!\},\phi_{\mathcal{E}0},\delta_{\mathcal{E}0}),}\\
&\multicolumn{3}{l}{\hfill\mathcal{R}(\![~(\underset{i=0\ldots\infty }{{\biguplus}}\{\!|(\theta,P[\mbox{{\itshape bn\/}}_i(P)/\mbox{{\itshape bn\/}}(P)][\mbox{{\itshape semiv\/}}_i(P)/\mbox{{\itshape semiv\/}}(P)])|\!\})~\uplus~\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}\}}\\
&\multicolumn{3}{l}{\mbox{and, }\mbox{{\itshape bn\/}}_i(P)=\{x_i\mid x\in\mbox{{\itshape bn\/}}(P)\},\mbox{{\itshape semiv\/}}_i(P)=\{\omega_i\mid \omega\in\mbox{{\itshape semiv\/}}(P)\}}\\
(\mathcal{R} 0)&\mathcal{R}(\![\rho]\!)~\phi_\mathcal{E}~{\delta_\mathcal{E}}&=&(\underset{(\theta,P)\in\rho}{\biguplus}p',\underset{(\theta,P)\in\rho}{\bigcup_\phi}\phi'_\mathcal{E},\underset{(\theta,P)\in\rho}{\bigcup_\delta}\delta'_\mathcal{E})\\
&&&\mbox{where, }(p',\phi'_\mathcal{E},\delta'_\mathcal{E})=\mathcal{E}(\![(\theta,P)]\!)~(\rho\backslash\{\!|(\theta,P)|\!\})~\phi_\mathcal{E}~{\delta_\mathcal{E}}\\
\end{array}$
\figrule
\end{footnotesize}
\caption{The non-standard semantics of semi-$\pi$.\label{nonstandpi}}
\end{figure}
The semantics utilises a multiset, $\rho$, to hold all processes in parallel with the analysed process, sharing the same copy of $\theta$. The contents of $\rho$ are interpreted in rule ($\mathcal{R} 0$), which uses $\uplus$ to group the choice of standard elements, $p\in Pi_\bot$, and operations, $\cup_\phi$ and $\cup_\delta$, to group the choice of non-standard elements, $\phi_\mathcal{E}$ and $\delta_\mathcal{E}$, respectively.  The rest of the rules ($\mathcal{E} 1$)--($\mathcal{E} 9$) deal with the individual cases of $P$.  There are a few interesting points to note.  Name and semiring value instantiations, ($\phi'_\mathcal{E}$,$\delta'_\mathcal{E}$), resulting in the residue of an input action  are neglected in rule ($\mathcal{E} 2$).  Such instantiations are instead considered in rule ($\mathcal{E} 3$) during communications between matching input and output actions.  In this rule, similar instantiations, ($\phi''_\mathcal{E}$,$\delta''_\mathcal{E}$), occurring under unfired output actions are also neglected.

In rule ($\mathcal{E} 4$), the matching process is resolved based on whether there exist $\phi_\mathcal{E}$-values of the matched names that are equal, or not. Since the semantics is precise, these values can only be singleton sets per choice of control flow.  A similar argument is true in rule ($\mathcal{E} 5$), where either expression may assume only a single value when closing it under $\delta_\mathcal{E}$. Hence, the semiring constraint is either satisfied, or not. In this rule, we define the following operation:
\[\textit{fold }f~e~\{x_1,\ldots,x_n\}=f(x_n,\ldots,f(x_1,e)\ldots)\]
applied to function, $Y_{\delta_\mathcal{E}}$, which instantiates each variable in a set of expressions to generate a new set of children expressions, as follows:
\[Y_{\delta_\mathcal{E}}(\omega,\{e_1,\ldots,e_n\})=(\underset{s\in\delta_\mathcal{E}(\omega)}{\bigcup}\{e_1[s/\omega]\})~\cup~\ldots~\cup~(\underset{s\in\delta_\mathcal{E}(\omega)}{\bigcup}\{e_n[s/\omega]\})\]

The rule for replication, ($\mathcal{E} 9$), defines the least fixed point meaning of a replicated process as the least upper bound of the (possibly infinite) poset, $\mathcal{F}$.  The computation of this least fixed point may not terminate within finite limits due to the infinite size of $D_\bot$.  Also, any spawned copies of $!P$ are $\alpha$-converted using the labelling mechanism, introduced in the previous section to maintain the process normality requirement.

The following theorem states that the non-standard semantics of semi-$\pi$ is {\itshape correct\/} with respect to the standard semantics.
\begin{theorem}[Correctness of the Non-Standard Semantics]\label{correctpi}
$ $\newline
$\forall P, \theta, \rho, \phi_\mathcal{S}, \phi_\mathcal{E}, \delta_\mathcal{S}, \delta_\mathcal{E}:(\mathcal{S}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}=p)~\wedge~(\mathcal{E}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{E}~\delta_\mathcal{E}=(p',\phi'_\mathcal{E},\delta'_\mathcal{E}))~~\Rightarrow~~p=p'$
\end{theorem}
Intuitively, the theorem states that for any system, $(\theta,P)$, it is possible to extract its standard meaning, as interpreted by $\mathcal{S}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{S}~\delta_\mathcal{S}$, from its non-standard meaning, as interpreted by $\mathcal{E}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{E}~\delta_\mathcal{E}$. In other words, the former is equal to the first element of the triple generated by the latter.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Semantics}\label{sect:abstract}
As we mentioned earlier in the previous section, the non-standard semantics of semi-$\pi$ contains least fixed point calculations that may not be computable due to the infinite nature of the concrete semantic domain.  Therefore, in this section, we introduce a couple of abstractions that help limit the size of the semantic domain to a finite level.  First, we need to introduce the definitions of \textit{abstract semiring}, \textit{abstract expression}, $\beta$ and $\succcurlyeq^\sharp$.
\begin{definition}
An abstract semiring, $(\mathcal{A}^\sharp,+^\sharp,\times^\sharp,1^\sharp,0^\sharp)$, is a semiring such that $|\mathcal{A}^\sharp|<\infty$.
\end{definition}
\begin{definition}
An abstract semiring expression, $e^\sharp$, is obtained from a standard expression, $e$, by replacing every occurrence of $s$, $+$, $\times$, $1$ and $0$, by their abstract forms, $s^\sharp$, $+^\sharp$, $\times^\sharp$, $1^\sharp$ and $0^\sharp$, respectively, and keeping occurrences of $\omega$ in $e$.
\end{definition}
\begin{definition}
define the abstraction, $\beta:\mathcal{A}\to\mathcal{A}^\sharp$, to return an abstract semiring value, $\beta(s)=s^\sharp$, corresponding to the concrete value, $s$.  We leave out the definition of $\beta$ here, since this is application-dependent.
\end{definition}
\begin{definition}
Define $s^\sharp\succcurlyeq^\sharp s'^\sharp$ as $s^\sharp+^\sharp s'^\sharp=s^\sharp$.  We may write $s^\sharp\succ^\sharp s'^\sharp$ to indicate that $s^\sharp\succcurlyeq^\sharp s'^\sharp$ and $s^\sharp\ne s'^\sharp$.
\end{definition}
Next, we introduce a finite predomain of tags, $\mbox{{\itshape Tag\/}}$, ranged over by $t, t'$ etc.  Given a process, $P$, we place distinct tags on all messages of output actions of $P$, except those occurring as $\pi$ in $\letsrvalue{\omega}{\pi}{n}$.  For example, tagging $!(\nu~\!x)\overline{y}\langle x\rangle.\overline{y}\langle y\rangle.y(z).\overline{y}\langle z\rangle$ results in $!(\nu~\!x)\overline{y}\langle x^t\rangle.\overline{y}\langle y^{t'}\rangle.y(z).\overline{y}\langle z^{t''}\rangle$.  Copies of tags can be renamed by subscripting them with the number of their copy. Hence, the replication above when spawning two copies, becomes:\newline

\noindent
$!(\nu~\!x)\overline{y}\langle x^t\rangle.\overline{y}\langle y^{t'}\rangle.y(z).\overline{y}\langle z^{t''}\rangle\mid$\\
$(\nu~\!x_1)\overline{y}\langle x_1^{t_1}\rangle.\overline{y}\langle y^{t'_1}\rangle.y(z_1).\overline{y}\langle z^{t''_1}_1\rangle\mid(\nu~\!x_2)\overline{y}\langle x_2^{t_2}\rangle.\overline{y}\langle y^{t'_2}\rangle.y(z_2).\overline{y}\langle z^{t''_2}_2\rangle$\newline

\noindent
We also define the following two functions:
\begin{itemize}
\item
$\mbox{{\itshape value\_of\/}}(\{t_1,\ldots,t_n\})=\{x_1,\ldots,x_m\}$, which when applied to a set of tags, it returns the corresponding messages.  For example,\[\mbox{{\itshape value\_of\/}}(\{t, t_1, t_2, t', t'_1, t'_2, t'', t''_1, t''_2\})=\{x, x_1, x_2, y, z, z_1, z_2\}\]
\item
$\mbox{{\itshape tags\_of\/}}(P)=\{t_1,\ldots,t_n\}$, which when applied to a process, $P$, it returns the set of tags in $P$.  For example, \[\mbox{{\itshape tags\_of\/}}(!(\nu~\!x)\overline{y}\langle x^t\rangle.\overline{y}\langle y^{t'}\rangle.y(z).\overline{y}\langle z^{t''}\rangle)=\{t, t', t''\}\]
\end{itemize}
Now, we define the following abstraction function for names, tags and semiring variables, which places an upper limit, $k$, on the total number of copies of names, tags and semiring variables that can be captured during the analysis.  In general, selecting $k$ is non-decidable and relies, to a great extent, on user's experience and the specific program being analysed.
\begin{definition}
Define the abstraction function, $\alpha_k:\mathbb{N}\times(N+Tag+\Omega)\to(N^\sharp+Tag^\sharp+\Omega^\sharp)$, as follows:\newline

\noindent
$\forall z\in(N+Tag+\Omega):\alpha_k(z)=\left\{\begin{array}{ll}
z_k,&\textit{if }z=z_i~\wedge~i>k\\
z,&\textit{otherwise}\\ 
\end{array}\right.$
\end{definition}
Note that $N^\sharp=N\backslash\{x_j\mid j>k\}$, $\mbox{{\itshape Tag\/}}^\sharp=\mbox{{\itshape Tag\/}}\backslash\{t_j\mid j>k\}$ and $\Omega^\sharp=\Omega\backslash\{\omega_j\mid j>k\}$.  Using the $\alpha_k$ abstraction function and the abstract semiring, $(\mathcal{A}^\sharp,+^\sharp,\times^\sharp,1^\sharp,0^\sharp)$, we can define the abstract environments, $\phi_\mathcal{A}:N^\sharp\to\wp(\mbox{{\itshape Tag\/}}^\sharp)$ and $\delta_\mathcal{A}:\Omega^\sharp\to\wp(\mathcal{A}^\sharp)$. Due to the imprecise nature of the abstract semantics, both $\phi_\mathcal{A}(x)$ and $\delta_\mathcal{A}(\omega)$ may be larger than singleton sets. This imprecision results from the inability to distinguish between the different copies of input parameters, tags and semiring variables beyond the $k^{\rm th}$ copy, and the use of the abstract semiring, $(\mathcal{A}^\sharp,+^\sharp,\times^\sharp,1^\sharp,0^\sharp)$. 

The abstract semantic domain, $D^\sharp_\bot=(N^\sharp\to\wp(\mbox{{\itshape Tag\/}}^\sharp))\times(\omega^\sharp\to\wp(\mathcal{A}^\sharp))$, has the following ordering based on subset inclusion (with $\cup_\phi$, $\cup_\delta$ defined as in the previous section, but over abstract rather than concrete environments):\newline

\noindent
$\forall (\phi_{\mathcal{A}1},\delta_{\mathcal{A}1}), (\phi_{\mathcal{A}2},\delta_{\mathcal{A}2})\in D_\bot^\sharp:~ (\phi_{\mathcal{A}1},\delta_{\mathcal{A}1})\sqsubseteq_{D^\sharp_\bot}(\phi_{\mathcal{A}2},\delta_{\mathcal{A}2})~~\Leftrightarrow$\newline
$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\phi_{\mathcal{A}1}\subseteq\phi_{\mathcal{A}2}~\wedge~\delta_{\mathcal{A}1}\subseteq\delta_{\mathcal{A}2}$\newline

\noindent
The bottom element, $\bot_{D^\sharp_\bot}$, is the pair, $(\phi_{\mathcal{A}0},\delta_{\mathcal{A}0})$, mapping every abstract name to the empty set and every abstract semiring variable to the empty set, respectively.  Using $D^\sharp_\bot$, the abstract semantics of semi-$\pi$ is defined by a function, $\mathcal{A}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}\in D^\sharp_\bot$, as shown in Figure \ref{fig:abstractpi}.
\begin{figure}[bht]
\begin{footnotesize}
\figrule
$\begin{array}{llll}
(\mathcal{A} 1)&\mathcal{A}(\![(\theta,{\bf 0})]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&(\phi_\mathcal{A},\delta_\mathcal{A})\\
(\mathcal{A} 2)&\mathcal{A}(\![(\theta,x(y).P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&(\phi_\mathcal{A},\delta_\mathcal{A})\\
(\mathcal{A} 3)&\mathcal{A}(\![(\theta,\overline{x}\langle y^t\rangle.P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&((\underset{(\theta,x'(z).P')\in\rho}{\bigcup_\phi}\phi'_\mathcal{A})~\cup_\phi\phi_\mathcal{A},(\underset{(\theta,x'(z).P')\in\rho}{\bigcup_\delta}\delta'_\mathcal{A})~\cup_\delta\delta_\mathcal{A})\\
&\multicolumn{3}{l}{\mbox{where, }(\phi'_\mathcal{A},\delta'_\mathcal{A})=\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho[(\theta,P')/(\theta,x'(z).P')]]\!)~\phi_\mathcal{A}[z\mapsto~\phi_\mathcal{A}(z)\cup\{t\}]~\delta_\mathcal{A}}\\
&\multicolumn{3}{l}{\mbox{and, }\exists t\in\phi_\mathcal{A}(x),t'\in\phi_\mathcal{A}(x'):\textit{value\_of}(t)=\textit{value\_of}(t')}\\
(\mathcal{A} 4)&\multicolumn{3}{l}{\mathcal{A}(\![(\theta,\match{x}{y}{P})]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}=}\\
&\multicolumn{3}{l}{\left\{\begin{array}{l}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A},
\mbox{ if }\exists t\in\phi_\mathcal{A}(x),t'\in\phi_\mathcal{A}(y):\textit{value\_of}(t)=\textit{value\_of}(t')\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A},\mbox{ otherwise}\\
\end{array}\right.}\\
(\mathcal{A} 5)&\multicolumn{3}{l}{\mathcal{A}(\![(\theta,\order{e_1}{e_2}{P})]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}=}\\
&\multicolumn{3}{l}{\left\{\begin{array}{l}
\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{A}~{\delta_\mathcal{A}},\mbox{ if }\exists e^\sharp\in (\textit{fold}~Y_{\delta_\mathcal{A}}~\{e_1^\sharp\}~\textit{semiv}(e_1^\sharp)),\\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e'^\sharp\in (\textit{fold}~Y_{\delta_\mathcal{A}}~\{e_2^\sharp\}~\textit{semiv}(e_2^\sharp)):e^\sharp\succcurlyeq^\sharp e'^\sharp\\
\mathcal{R}(\![\rho]\!)~\phi_\mathcal{A}~{\delta_\mathcal{A}}, \mbox{ otherwise}\\
\end{array}\right.}\\
(\mathcal{A} 6)&\mathcal{A}(\![(\theta,P\mid Q)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\{\!|(\theta,Q)|\!\}\uplus\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}\\
(\mathcal{A} 7)&\mathcal{A}(\![(\theta,(\nu x)P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}\\
(\mathcal{A} 8)&\multicolumn{3}{l}{\mathcal{A}(\![(\theta,\letsrvalue{\omega}{\pi,n}{P})]\!)~\rho~\phi_\mathcal{A}~{\delta_\mathcal{A}}=}\\
&\multicolumn{3}{l}{\hfill\mathcal{R}(\![\{\!|(\theta,P)|\!\}\uplus\rho]\!)~\phi_\mathcal{A}~{\delta_\mathcal{A}}[\omega\mapsto\delta_\mathcal{A}(\omega)\cup\{\beta(\theta(\pi,n))\}]}\\
(\mathcal{A} 9)&\mathcal{A}(\![(\theta,!P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}&=&\bigsqcup\mathcal{F}\\
&\multicolumn{3}{l}{\mbox{where, }\mathcal{F}=\{(\phi_{\mathcal{A}0},\delta_{\mathcal{A}0}),\mathcal{R}(\![~\underset{i=0\ldots\infty}{\biguplus}\{\!|(\theta,\mbox{{\itshape ren\/}}(P,i,\alpha_k))|\!\}~\uplus~\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}\}}\\
&\multicolumn{3}{l}{\mbox{and, }\forall x\in\mbox{{\itshape bn\/}}(P),t\in\textit{tags\_of}(P),\omega\in\textit{semiv}(P):}\\
&\multicolumn{3}{l}{~~~~~~~\mbox{{\itshape ren\/}}(P,i,\alpha_k)=P[\alpha_k(x_i)/x][\alpha_k(t_i)/t][\alpha_k(\omega_i)/\omega]}\\
(\mathcal{R} 0)&\mathcal{R}(\![\rho]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}&=&(\underset{(\theta,P)\in\rho}{\bigcup_\phi}\phi'_\mathcal{A},\underset{(\theta,P)\in\rho}{\bigcup_\delta}\delta'_\mathcal{A})\\
&&&\mbox{where, }(\phi'_\mathcal{A},\delta'_\mathcal{A})=\mathcal{A}(\![(\theta,P)]\!)~(\rho\backslash\{\!|(\theta,P)|\!\})~\phi_\mathcal{A}~\delta_\mathcal{A}\\
\end{array}$
\figrule
\end{footnotesize}
\caption{The abstract semantics of semi-$\pi$.\label{fig:abstractpi}}
\end{figure}

The multiset, $\rho$, holds as usual all the processes composed in parallel with the interpreted process, along with a copy of $\theta$. The rules of the abstract semantics are described informally as follows.  Rules, $(\mathcal{A} 1)$ and $(\mathcal{A} 2)$, for null processes and input actions do not change the values of $\phi_\mathcal{A}$ and $\delta_\mathcal{A}$, since no communications take place in these rules. In rule $(\mathcal{A} 3)$, the meaning of an output action is composed from the two cases of no-communications and communications with matching input actions in $\rho$. A communication is fired whenever the sets of values of two channels, as given by $\phi_\mathcal{A}$, have a non-empty intersection.  The effect of the communication is reflected by adding the tag of the output message to the $\phi_\mathcal{A}$-value of the input parameter. 

In rule $(\mathcal{A} 4)$, the matching of two names leads to either choosing process, $P$, or not, based on the presence of at least one $\phi_\mathcal{A}$-value for each of the matched names that are equal.  A similar argument follows in rule $(\mathcal{A} 5)$, when resolving semiring constraints. The definition of \textit{fold} is similar to that of the previous section, however, we redefine $Y_{\delta_\mathcal{A}}$ as follows:
\[Y_{\delta_\mathcal{A}}(\omega^\sharp,\{e^\sharp_1,\ldots,e^\sharp_n\})=(\underset{s^\sharp\in\delta_\mathcal{A}(\omega^\sharp)}{\bigcup}\{e^\sharp_1[s^\sharp/\omega^\sharp]\})~\cup\ldots\cup~(\underset{s^\sharp\in\delta_\mathcal{A}(\omega^\sharp)}{\bigcup}\{e^\sharp_n[s^\sharp/\omega^\sharp]\})\]
In rule $(\mathcal{A} 8)$, we use the abstraction, $\beta$, to abstract a concrete semiring value as returned by $\theta(\pi,n)$ to an element of the abstract set, $\mathcal{A}^\sharp$.  The rule for replicated processes, $(\mathcal{A} 9)$, attaches abstract subscripts to bound names, tags and semiring variables of the spawned processes according to the copy number of each process.  This will only maintain the distinction requirement up to the $k$th copy, since after that, copies will be identified.  Therefore, this semantics will necessarily be approximate and the size of $D_\bot^\sharp$ will necessarily be finite. The rule also defines a least fixed point meaning of the replication as the least upper bound of a poset, $\mathcal{F}$, containing the bottom element, $\bot_{D^\sharp_\bot}$.  Since the semantic domain, $D^\sharp_\bot$, is finite in nature, $\mathcal{F}$ may only contain a finite number of $\phi_\mathcal{A}$, $\delta_\mathcal{A}$ elements.  As a result, the calculation of the least fixed point is guaranteed to terminate.  This is stated more formally as follows.
\begin{theorem}[Termination of the least fixed point calculation]
$ $\\
The calculation of rule $(\mathcal{A} 9)$ terminates.
\end{theorem}
\noindent
\textit{Proof Sketch.} We give a sketch of the proof of the termination property. Two requirements must be satisfied.  First, the semantic domain must be finite. This is satisfied by the definition of $D^\sharp_\bot$ and the fact that the number of names, tags and semiring values remains finite. The second requirement is to prove that $\mathcal{R}(\![~\underset{i}{{\biguplus}}\{\!|(\theta,\mbox{{\itshape ren\/}}(P,i,\alpha_k))|\!\}~]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}\sqsubseteq_{D^\sharp_\bot}\mathcal{R}(\![~\underset{i+1}{{\biguplus}}\{\!|(\theta,\mbox{{\itshape ren\/}}(P,i+1,\alpha_k))|\!\}~]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}$ (i.e., proving that the meaning is monotonic with respect to an increment in the number of copies of $(\theta,P)$). To prove this, we simplify the inequality into $\mathcal{R}(\![E]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}\sqsubseteq\mathcal{R}(\![E\uplus\{\!|(\theta,\textit{ren}(P,i+1,\alpha_k))|\!\}]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}$, where $E=\underset{i}{\biguplus}\{\!|(\theta,\textit{ren}(P,i,\alpha_k))|\!\}$. This result can be proven by induction over the rules of $\mathcal{A}$. In particular, the most interesting rules are those of $(\mathcal{A} 3)$ and $(\mathcal{A} 8)$, where the values of $\phi_\mathcal{A}$ and $\delta_\mathcal{A}$ change. The proof relies on the fact that any communications and semiring value retrievals taking place in $\mathcal{R}(\![E]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}$ will necessarily take place in $\mathcal{R}(\![E\uplus\{\!|(\theta,\textit{ren}(P,i,\alpha_k))|\!\}]\!)~\phi_\mathcal{A}~\delta_\mathcal{A}$, since the latter is a larger system than the former, and larger systems always induce at least as much communications and semiring value retrievals as the smaller ones.\hfill$\square$

The safety of the abstract semantics can now be established formally in the following theorem.

\begin{theorem}[Safety of the abstract semantics of semi-$\pi$]\label{theor3}
$ $

\noindent
$\forall \theta, P, \rho, \phi_\mathcal{E}, \phi_\mathcal{A}, \delta_\mathcal{E}, \delta_\mathcal{A},x,\omega,\alpha_k,\beta,$\newline $\mathcal{E}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{E}~\delta_\mathcal{E}=(p,\phi'_\mathcal{E},\delta'_\mathcal{E}),\mathcal{A}(\![(\theta,P)]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}=(\phi'_\mathcal{A},\delta'_\mathcal{A}):$

\noindent
$(\exists y\in\phi_\mathcal{E}(x)~\Rightarrow~\exists t\in\phi_\mathcal{A}(\alpha_k(x)):\mbox{{\itshape value\_of\/}}(\{t\})=\alpha_k(y))~\wedge$\newline
$(\exists s\in\delta_\mathcal{E}(\omega)~\Rightarrow~\exists s^\sharp\in\delta_\mathcal{A}(\alpha_k(\omega)):s^\sharp=\beta(s))$

$\Rightarrow$

\noindent
$(\exists y\in\phi'_\mathcal{E}(x)~\Rightarrow~\exists t\in\phi'_\mathcal{A}(\alpha_k(x)):\mbox{{\itshape value\_of\/}}(\{t\})=\alpha_k(y))~\wedge$\newline
$(\exists s\in\delta'_\mathcal{E}(\omega)~\Rightarrow~\exists s^\sharp\in\delta'_\mathcal{A}(\alpha_k(\omega)):s^\sharp=\beta(s))$
\end{theorem}

The safety theorem above states that values present in the final environments resulting from the concrete non-standard semantics will always be present, as abstract tags and elements of the abstract semiring, in the environments resulting from the abstract semantics.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analysing the Satisfaction of Semiring Constraints}\label{sect:qanalysis}
Semiring constraints in fact allow us to define a Constraint Satisfaction Problem (CSP) \cite[\S 2.1.1]{dechter1}, as follows:
\[\mathcal{C}=(\{\omega_1,\ldots,\omega_n\},\{\mathcal{A}_1,\ldots,\mathcal{A}_n\},\{e_1\succcurlyeq e_2,\ldots,e_{k}\succcurlyeq e_{k+1}\})\]
where $\omega_{i=1\ldots n}\in\underset{j=1}{\overset{k+1}{\bigcup}}\textit{semiv}(e_j)$.  The solution to this problem is obtained by taking ``good'' instantiations of the semiring variables, $\omega_1\ldots\omega_n$, i.e. instantiations that satisfy the set of constraints, $\{e_1\succcurlyeq e_2,\ldots,e_{k}\succcurlyeq e_{k+1}\}$.  Hence, a solution is defined as a set, $\textit{Sol}(\mathcal{C})=\{\omega_1\mapsto s_1\in\mathcal{A}_1,\ldots,\omega_n\mapsto s_n\in\mathcal{A}_n\}$.  Furthermore, we refer to the set of all solutions as $\textit{SOL}(\mathcal{C})=\{\textit{Sol}_1(\mathcal{C}),\ldots,\textit{Sol}_m(\mathcal{C})\}$.

From the set, $\textit{SOL}(\mathcal{C})$, it is possible to relate a solution to the property of name substitutions as follows.  Assume that $C$ is a context, i.e. it is a process with a hole, $P[.]$.  This allows us to write a process with a string of semiring constraints as $C[\order{e_1}{e_2}{\ldots\order{e_{k}}{e_{k+1}}{P}}]$.  Then, we have the following two environments:
\begin{eqnarray*}
\phi_{\mathcal{A}1}&=&\textit{fst}(\mathcal{A}(\![(\theta,C[P])]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A})\\
\phi_{\mathcal{A}2}&=&\textit{fst}(\mathcal{A}(\![(\theta,C[{\bf 0}])]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A})
\end{eqnarray*}
Which result from replacing $\order{e_1}{e_2}{\ldots\order{e_k}{e_{k+1}}{P}}$ once by $P$ and once by ${\bf 0}$.  Now, we define the \textit{difference} between the two environments as follows:
\[\phi^P_\mathcal{A}=\phi_{\mathcal{A}1}\backslash\phi_{\mathcal{A}2}\]
The $\phi^P_\mathcal{A}$ environment represents the effect reflected in name substitutions of satisfying the set of constraints, $\{e_1\succcurlyeq e_2,\ldots,e_k\succcurlyeq e_{k+1}\}$.

The following definition formalised \textit{name substitution/CSP dependency}.
\begin{definition}\label{prop:csp}
Given a system, $(\theta,C[\order{e_1}{e_2}{\ldots\order{e_k}{e_{k+1}}{P}}])$, an abstract interpretation, $\mathcal{A}(\![(\theta,C[\order{e_1}{e_2}{\ldots\order{e_k}{e_{k+1}}{P}}]))]\!)~\rho~\phi_\mathcal{A}~\delta_\mathcal{A}=(\phi'_\mathcal{A},\delta'_\mathcal{A})$, and a difference environment, $\phi^{P}_\mathcal{A}$, then every substitution, $[x^\sharp\mapsto\{a_1^\sharp,\ldots,a_n^\sharp\}]\in\phi^{P}_\mathcal{A}$, is dependent on reaching one or more of the solutions, $\textit{SOL}(\mathcal{C}^\sharp)$, such that:\newline

\noindent
$\mathcal{C}^\sharp=$\newline$(\{\omega^\sharp\mid\omega^\sharp\in\underset{j=1}{\overset{k+1}{\bigcup}}\textit{semiv}(e^\sharp_j)\},\{set^\sharp\mid set^\sharp=\delta'_\mathcal{A}(\omega^\sharp)\},\{e^\sharp_1\succcurlyeq^\sharp e^\sharp_2,\ldots,e^\sharp_k\succcurlyeq^\sharp e^\sharp_{k+1}\})$
\end{definition}
The property states that a name substitution can only occur subject to the satisfaction of the CSP over the abstract constraints.  Since we are dealing with normal processes only, with no occurrences of homonymous semiring variables or bound names, it is possible to relate every $\omega^\sharp$ to some abstract action, $\pi^\sharp$, and name, $z^\sharp$, by observing a subprocess, $\letsrvalue{\omega}{\pi,z}{P}$, in the syntax of the analysed process.  This will allows us to relate name substitutions to the cost of actions under certain circumstances.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example: Adaptive Router}\label{sect:example}
We consider in this section an example of a simplified adaptive router.  The system consists mainly of a process, \textit{Router}, which is connected to an $n$ number of other routers through channels, $\textit{out}_i$, for $i=1\ldots n$.  The router repeatedly accepts a message (the destination) after which it queries the state $\theta$ for the cost of routing the message over each of its output connections. One may think of $\theta$ as implementing some algorithm for the calculation of the shortest path, for example Dijkstra's \cite{dijkstra1}.  Using these costs, the router decides which connection is best to send the message over. The specification of the system is shown in Figure \ref{fig:routing}, in which it runs the router process for the case of five connections.
\begin{figure}[!bht]
\begin{footnotesize}
\figrule
$\begin{array}{lll}
\textit{Router}(n)&~\eqdef~~&!\textit{route}(\textit{\textit{dest}}).\\
&&\letsrvalue{\omega_{1}}{\overline{\textit{out}_1}\langle\textit{dest}\rangle,\textit{dest}}{}\\
&&\vdots\\
&&\letsrvalue{\omega_{n}}{\overline{\textit{out}_n}\langle\textit{dest}\rangle,\textit{dest}}{}\\
&&\letsrvalue{\omega_{1+n}}{\textit{out}_{1}(x_{1}),\textit{dest}}{}\\
&&\vdots\\
&&\letsrvalue{\omega_{n+n}}{\textit{out}_{n}(x_{n}),\textit{dest}}{}\\
&&\underset{i=1}{\overset{n}{\prod}}~(\underset{j=\textit{min}(\{1,\ldots,n\}\backslash i)}{\overset{\textit{max}(\{1,\ldots,n\}\backslash i)}{\bigodot}}\order{(\omega_i\times\omega_{n+i})}{(\omega_{j}\times\omega_{n+j})}{})~\overline{\textit{out}_i}\langle\textit{dest}^t\rangle\\
&&\\
\textit{System}&~\eqdef~~&(\theta,\textit{Router}(5)~\mid~\overline{\textit{route}}\langle\textit{our\_dest}^{t'}\rangle~\mid~\underset{i=1}{\overset{5}{\prod}}\textit{out}_i(x_i))\\
\end{array}$
\figrule
\end{footnotesize}
\caption{The Specification of the Routing Protocol.\label{fig:routing}}
\end{figure}

Here, we use the special symbol,
\[(\underset{i=1}{\overset{k}{\bigodot}}\order{e_i}{e'_i}{})~P\]
as a shorthand for,
\[\order{e_1}{e'_1}{\ldots\order{e_k}{e'_k}{P}}\]
We start the analysis of this system by first adopting the assumptions:
\begin{itemize}
\item
The concrete semiring is the weighted semiring, $(\mathbb{R}^+,\textit{min},+,+\infty,0)$.
\item
$\theta$ holds values for the different actions, as follows:\newline
\noindent
$\theta(\overline{\textit{out}_1}\langle\textit{our\_msg},\textit{our\_dest}\rangle,\textit{our\_dest})=30$\newline
$\theta(\overline{\textit{out}_2}\langle\textit{our\_msg},\textit{our\_dest}\rangle,\textit{our\_dest})=3$\newline
$\theta(\overline{\textit{out}_3}\langle\textit{our\_msg},\textit{our\_dest}\rangle,\textit{our\_dest})=3$\newline
$\theta(\overline{\textit{out}_4}\langle\textit{our\_msg},\textit{our\_dest}\rangle,\textit{our\_dest})=1010$\newline
$\theta(\overline{\textit{out}_5}\langle\textit{our\_msg},\textit{our\_dest}\rangle,\textit{our\_dest})=60$\newline
$\theta(\textit{out}_1(x_1,y_1),\textit{our\_dest})=100$\newline
$\theta(\textit{out}_2(x_2,y_2),\textit{our\_dest})=5$\newline
$\theta(\textit{out}_3(x_3,y_3),\textit{our\_dest})=10000$\newline
$\theta(\textit{out}_4(x_4,y_4),\textit{our\_dest})=50000$\newline
$\theta(\textit{out}_5(x_5,y_5),\textit{our\_dest})=5$\newline
\item
The abstract semiring is $(\{\textit{low},\textit{medium},\textit{high}\},\textit{min},\textit{max},\textit{high},\textit{low})$. Additionally, we define $\beta$ as follows:
\[\forall r\in\mathbb{R}^+:\beta(r)=\left\{\begin{array}{ll}
\textit{low},&\text{if }r<10\\
\textit{medium},&\text{if }10\le r\le 100\\
\textit{high},&\text{if }r>100\\
\end{array}\right.\]
\item
We assume a non-uniform analysis with the abstraction function is $\alpha_5$.
\item
We allow ourselves to abuse the notation by using parameterised non-recursive definitions, like $\text{Router}(n)$.
\end{itemize}
Next, we run the abstract interpretation for the following systems:\newline

\noindent
$\mathcal{A}(\![~\textit{System}~]\!)~\{\!||\!\}~\phi_{\mathcal{A}0}~\delta_{\mathcal{A}0}=(\phi_\mathcal{A},\delta_\mathcal{A})$\newline
\noindent
$\mathcal{A}(\![~\textit{System}[{\bf 0}/\textit{string}]~]\!)~\{\!||\!\}~\phi_{\mathcal{A}0}~\delta_{\mathcal{A}0}=(\phi'_{\mathcal{A}i},\delta'_{\mathcal{A}i})$\newline
$\mathcal{A}(\![~\textit{System}[\overline{\textit{out}_i}\langle \textit{msg},\textit{dest}\rangle/\textit{string}]~]\!)~\{\!||\!\}~\phi_{\mathcal{A}0}~\delta_{\mathcal{A}0}=(\phi''_{\mathcal{A}i},\delta''_{\mathcal{A}i})$\newline

\noindent
where,\newline

\noindent
$\textit{string}~\eqdef~~(\underset{j=\textit{min}(\{1,\ldots,n\}\backslash i)}{\overset{\textit{max}(\{1,\ldots,n\}\backslash i)}{\bigodot}}\order{\omega_i\times\omega_{n+i}}{\omega_{j}+\omega_{n+j}}{})~\overline{\textit{out}_i}\langle \textit{msg},\textit{dest}\rangle$\newline

\noindent
for all the cases of $i\in\{1,\ldots,5\}$.  As a result, it is now possible to construct the following difference environments:\newline

\noindent
$\phi^P_{\mathcal{A}i}=\phi''_{\mathcal{A}i}\backslash\phi'_{\mathcal{A}i}$~~~for each value of $i\in\{1,\ldots,5\}$\newline

\noindent
Examining these difference environments, we find that the only environment which is not empty is $\phi^P_{\mathcal{A}2}=\{(x_{2},\{\textit{t}_2\})\}$, where $\textit{value\_of}(\{t_2\})=\{\textit{dest}_2\}$.  This implies that only the second set of constraints and the second output are capable of influencing the routing of the message to its destination.  The reason is because $\beta(\omega_{2_1})\times\beta(\omega_{7_1})$ constitutes in fact the best abstract semiring value among all the other possible values (based on a \textit{min} ordering).  Consequently, our CSP-based Property \ref{prop:csp} as defined in the previous section allows us to state that the name substitution, $\{(x_{2},\{\textit{t}_2\})\}$, is dependent reaching the solution that $\beta(\omega_{2_2})=\beta(\omega_{7_2})=\textit{low}$ in every constraint, and that for the each of the remaining semiring variables, that at least one variable occurring in each constraint will reach one of the abstract values of \textit{medium} or \textit{high}.  Put more precisely, the costs of $\overline{\textit{out}_2}\langle\textit{our\_dest}\rangle$ and $\textit{out}_2(x_2)$ are the best.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion and Future Work}\label{sect:conclusion}
We have presented a static analysis of semi-$\pi$: an extension of the $\pi$-calculus that incorporates capabilities for the retrieval of semiring values of communication actions and then allows these values to be reasoned about in semiring constraints.  The analysis captures the property of name substitutions and instantiations of semiring variables using semiring values.  The results of the analysis allow us to relate name substitutions to the satisfaction of semiring constraints, and ultimately, to the cost of communication actions.  We applied the analysis to a simple adaptive routing example.

In the future, we are planning to implement the analysis in a functional programming language, like SML.  Such languages are quite suitable to the syntax-directed approach adopted in the definition of our analysis.  Moreover, we are planning to apply the analysis to more interesting adaptive network routing algorithms and adaptive power-saving in small devices.  Another interesting extension would be to model the cost of cryptographic operations, in languages like the spi calculus.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliography{../biblio}
\end{document}
