%\begin{abstract}

%\end{abstract}

\section{Introduction}
\label{sec:intro}

In this paper we investigate how formal software verification systems
can be improved by utilising parallel assignment statements.
Specifically, we are interested in performing this static
transformation on programs written in general-purpose programming
languages such as C or Java.  The modified program is then verified
with an extended model checking tool which interacts with theorem
provers and decision procedures to reason about software abstractions.

Verification tools such as MAGIC (\textbf{M}odular \textbf{A}nalysis
of pro\textbf{G}rams \textbf{I}n \textbf{C})
\cite{website:magic,sagar:modularverification} employ a framework
known as \textbf{C}ounter\textbf{E}xample-\textbf{G}uided
\textbf{A}bstraction \textbf{R}efinement (CEGAR)
\cite{cegar,sagar:efficientverification} to iteratively create more
precise abstractions of the program until the desired properties can
be proven or a real counterexample is generated.

MAGIC provides a compositional framework that can be used to verify
concurrent C programs against a range of safety and liveness
specifications~\cite{sagar:efficientverification,IFM05,FACJ05}. In this
context each atomic assignment is represented as a state in the
software model and the cartesian product of this model is then taken with
the specification B\"uchi automaton.

Our approach is to analyze the control-flow graph (CFG) and combine
sequential assignments into parallel assignment blocks. Since the
iterated CEGAR framework can result in a large number of passes over
the same parts of the CFG, the cumulative savings obtained by this
compression procedure can lead to significant
speed-ups. Algorithmically, weakest precondition computations, which
typically involve interacting with theorem provers, become more
efficient. Moreover, in the context of concurrent C programs, the
reduction in the number of states in individual components has a
multiplicative effect on the number of states of the whole system.

\subsection{Outline}

In Section~2, parallel assignment statements are introduced.  The
classical NP-complete parallel assignment problem is first considered,
and then an additional restriction is added to create a special case
in which the problem is tractable.  The parallel assignment problem is
then discussed in the context of weakest precondition computations.
In this special situation where statements can be assumed to execute
truly concurrently, we find an even better algorithm for compressing
multiple sequential assignment statements into a single parallel
assignment.

In Section~3, experiments are presented which show the level of
assignment compression which can be achieved from a broad class of
software.  The algorithms from Section~2 have also been implemented in
the ComFoRT reasoning framework, and results are presented showing the
time and memory space improvements for model checking a selection of
applications. Finally, we discuss future research directions in
Section~4.

