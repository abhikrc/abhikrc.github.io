<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>SVV'03, a workshop of ICLP'03</title>
</head>

<body background="./CHALK.JPG"> 

<p><font face="Arial" size="2"><a name="six"></a></font>
<font face="Arial" size="4">&nbsp;<u>Provably Correct Code 
Generation: A Case Study</u>&nbsp; </font></p>
<p><font face="Arial" size="2"><b>Authors:</b>&nbsp; Qian Wang, Gopal Gupta 
(Univ. of Texas at Dallas, USA)</font></p>
<p><font face="Arial" size="2"><b>Abstract.</b> Provably correct compilation is 
an important aspect in development of high assurance <br>
software systems. In this paper we present an approach to provably correct 
compilation based on Horn <br>
logical semantics of programming languages and partial evaluation. We also show 
that continuation <br>
semantics can be expressed in the Horn logical framework, and introduce Definite 
Clause Semantics. <br>
We illustrate our approach by developing a complete semantics for the SCR 
specification language, and <br>
using it to (automatically) generate target code in a provably correct manner.
<br>
&nbsp;</font></p>
<p><font face="Arial" size="2"><a name="fourteen"></a>&nbsp;</font><u><font face="Arial" size="4"> 
A Denotational Approach to the Static Analysis of Cryptographic Processes</font></u></p>
<p><font face="Arial" size="2"><b>Authors:</b> Benjamin Aziz, G.W. Hamilton and 
D. Gray (Dublin City University, Ireland)<br>
<b>Abstract:</b><br>
We present in this paper, a non-uniform static analysis for detecting the 
term-substitution property in <br>
processes specified in the spi calculus. The property is essential in defining 
security breaches, like <br>
secrecy and authenticity. The analysis is fully denotational, preserving 
compositionality and facilitating <br>
implementations in functional programming.</font></p>
<p><font face="Arial" size="2"><a name="five"></a></font>
<font face="Arial" size="4">&nbsp; <u>Verification of 
Scenario-based Specifications using Templates&nbsp; </u> </font></p>
<p><font face="Arial" size="2"><b>Authors:</b> Girish Palshikar, Purandar 
Bhaduri (Tata Research Development and Design Centre, India)</font></p>
<p><font face="Arial" size="2"><b>Abstract:</b> Specifying dynamic behaviour of 
a system by listing scenarios of its<br>
interactions has become a popular practice. Message sequence chart (MSC) is a<br>
rigorous and widely used notation for specifying such scenarios of system 
behaviour.<br>
High-level MSCs (HMSC) provide hierarchical and modular composition<br>
facilities for constructing complex scenarios from basic MSCs. Although<br>
the general problem of formal verification of properties of HMSCs is 
intractable,<br>
we propose a framework for restricted verification. We present simple templates<br>
for commonly useful types of properties and discuss efficient algorithms<br>
for verifying them.</font></p>
<p><font face="Arial" size="2"><a name="four"></a></font>
<font face="Arial" size="4">&nbsp; <u>&nbsp;A Trace Logic 
for Local Security Properties&nbsp;&nbsp; </u> </font></p>
<p><font face="Arial" size="2"><b>Authors:</b>&nbsp; Ricardo Corin, Antonio 
Durante, Sandro Etalle, Pieter Hartel&nbsp; (Univ. of Twente, Netherlands and 
Universita di Roma, Italy)</font></p>
<p><font size="2" face="Arial"><b>Abstract:</b> We propose a new simple trace 
logic that can be used to specify local security properties, i.e. security 
properties that refer to a single participant of the protocol specification. Our 
technique allows a protocol designer to provide formal specification of the 
desired security properties, and integrate them naturally into the design 
process of cryptographic protocols. Furthermore, the logic can be used for 
formal verification. We illustrate the utility of our technique by exposing new 
attacks on the well studied protocol TMN.</font></p>
<p>&nbsp;</p>
<p><font face="Arial" size="2"><a name="nine"></a></font>
<font face="Arial" size="4">&nbsp;<u>Logical Specification and 
Analysis of Fault Tolerant Systems Through Partial Model Checking</u>&nbsp; </font></p>
<p><font face="Arial" size="2"><b>Authors: </b>S. Gnesi, G. Lenzini and F. 
Martinelli&nbsp; (C.N.R., Italy)</font></p>
<p><font face="Arial" size="2"><b>Abstract</b>. This paper presents a logical 
characterization of fault tol­ <br>
erance and proposes a framework for a formal analysis based on partial <br>
model checking techniques. Our framework requires a fault tolerant (can­ <br>
didate) systems to be modeled using a formal calculus, for example the <br>
CCS process algebra. To this aim we propose a uniform modeling scheme <br>
in which to specify a formal model of the system, its failing behavior (with <br>
respect to fault occurrences) and possibly its fault­recovering procedures. <br>
Once a formal model is provided into our scheme, fault tolerance with <br>
respect to a given property, can be formalized, in a logic formalism, as an <br>
equational µ­calculus formula expressing all the fault scenarios satisfying <br>
that property. This logical characterization understands the analysis of <br>
fault tolerance as a form of analysis of open systems. Thank to partial <br>
model checking strategies such a characterization can be made indepen­ <br>
dent on any particular fault assumption. Such a logic characterization <br>
makes possible the fault­tolerance verification problem be expressed as a <br>
general µ­calculus validation problem, for solving which many theorem <br>
proof techniques and tools are available. Moreover we present several <br>
analysis methods that show how much flexible is our approach. <br>
<b>Keywords:</b> Fault Tolerant Systems, Formal Verification, Partial Model 
Checking </font></p>
<p><font face="Arial" size="2"><a name="thirteen"></a></font>
<font face="Arial" size="4">&nbsp;<u>Compositional Properties of 
Sequential Processes&nbsp; </u> </font></p>
<p><font face="Arial" size="2"><b>Authors:</b> Naijun Zhan (Mannheim Universitat, 
Germany)</font></p>
<p><font face="Arial" size="2"><b>Abstract.</b> It is widely agreed that the modular method is one of the
<br>
most effective methods to specify and verify complex systems in order to <br>
avoid combinatorial explosion. FLC ( Fixpoint Logic with Chop) is an <br>
important modal logic because of its expressivity and logic properties, <br>
e.g., it is strictly more expressive than the µ­calculus. In this paper, we <br>
study the compositionality of FLC, namely, to investigate the connection <br>
between the connectives of the logic and the constructors of programs. <br>
To this end, we firstly extend FLC with a nondeterministic operator ``+'' <br>
(FLC + for the extension) and then establish a correspondence between <br>
the logic and the basic process algebra with deadlock and termination <br>
(abbreviated by BPA # # ). Finally, we show that as a by­product of the <br>
correspondence characteristic formulae for strong ( observational) bisim­ <br>
ulation on BPA # # can be constructed compositionally directly from the <br>
syntax of processes. <br>
<b>Keywords:</b> chop operator, modal logic, compositionality, verification, 
bisim­ <br>
ulation, characteristic formula, process algebra </font> </p>
<p>&nbsp;</p>
<p><font face="Arial" size="2"><a name="ten"></a></font>
<font face="Arial" size="4">&nbsp;<u>Equational Abstractions for Model 
Checking Erlang Programs</u> </font></p>
<p><font face="Arial" size="2"><b>Authors: </b>Thomas Noll (Aachen University, 
Germany)</font></p>
<p><font face="Arial" size="2"><b>Abstract </b><br>
This paper provides a contribution to the formal verification of programs 
written in the con­ <br>
current functional programming language Erlang, which is designed for 
telecommunication appli­ <br>
cations. It presents a formal description of this language in Rewriting Logic, a 
unified semantic <br>
framework for concurrency which is semantically founded on conditional term 
rewriting modulo <br>
equational theories. In particular it demonstrates the use of equations for 
defining abstraction <br>
mappings which reduce the state space of the system.</font><font face="Arial" size="4"> </font></p>
<p>&nbsp;</p>
<p><font face="Arial" size="2"><a name="twelve"></a></font>
<font face="Arial" size="4">&nbsp;<u>Verifying a UMTS protocol using 
SPIN and EASN&nbsp; </u> </font></p>
<p><font face="Arial" size="2"><b>Authors: </b>M. Luukkainen, Vivek K. Shanbhag 
and K. Gopinath (University of Helsinki, Finland and&nbsp; Indian Institute of 
Science)</font></p>
<p><font face="Arial" size="2"><b>Abstract:</b>&nbsp; Next generation mobile 
protocols have become very complex and it is becoming increasingly difficult for 
standards bodies to be sure of the correctness of protocols during the 
standardization process. A convenient notation for specifying protocols and a 
means to analyze their behavior at a certain level of abstraction could be quite 
useful. Model-checking has turned out to be an efficient and relatively 
easy-to-use technique in the verification of formally described behaviors. 
However, there are two major drawbacks in using model-checking: one is state 
explosion (the behavior models of real-life programs tend to be extremely 
large); the other factor limiting industrial applicability of model checkers is 
their restricted input language. For instance, in the field of 
telecommunications, the standards define the data model of the protocols using 
the ASN.1 notation and it would be simpler if the verification models could be 
directly built using this 'native' data definition language of the 
telecommunication industry.</font></p>
<p><font face="Arial" size="2">In this paper, we consider model checking in the 
RLC protocol in the UMTS system that is seeing ongoing development as a third 
generation mobile communication system. We briefly describe EASN, a model 
checker wherein the behavior can be formally specified through a language based 
upon Promela for control structures but with data models form ASN.1 We discuss 
the verification problem for RLC and then discuss the results of using EASN on 
the verification problem and compare with SPIN which is also the basis for the 
EASN realization.</font></p>
<p><font face="Arial" size="2">As a side-effect of realizing EASN, we have been 
able to locate some intricate performance bugs in the SPIN implementation. We 
believe that this type of &quot;n-version&quot; programming is necessary to increase 
confidence in model checkers.</font></p>
<p><font face="Arial" size="2"><b>Keywords: </b>Model Checking, Spin, Promela, 
ASN.1, Telecommunication protocols, RLC, UMTS </font></p>
<p>&nbsp;</p>
<p><font face="Arial" size="2"><a name="two"></a></font>
<font face="Arial" size="4">&nbsp;<u>Insights to Angluin's Learning&nbsp;&nbsp;&nbsp;</u></font></p>
<p><font face="Arial" size="2"><b>Authors:&nbsp; </b>Therese Berg, Bengt Jonsson, 
Martin Leucker, Mayank Saksena (Uppsala Univ, Sweden)</font></p>
<p><font face="Arial" size="2"><b>Abstract</b><br>
Among other domains, learning finite-state machines is important for obtaining a<br>
model of a system under development, so that powerful formal methods such as<br>
model checking can be applied.</font></p>
<p><font face="Arial" size="2">A prominent algorithm for learning such devices was developed by Angluin. We<br>
have implemented this algorithm in a straightforward way to gain further 
insights to<br>
practical applicability. Furthermore, we have analyzed its performance on 
randomly<br>
generated as well as real-world examples. Our experiments focus on the impact of<br>
the alphabet size and the number of states on the needed number of membership<br>
queries. Additionally, we have implemented and analyzed an optimized version<br>
for learning prefix-closed regular languages. Memory consumption is one major<br>
obstacle when we attempted to learn large examples.<br>
We see that prefix-closed languages are relatively hard to learn compared to<br>
arbitrary regular languages. The optimization, however, shows positive results.<br>
<b>Key words:</b> deterministic finite-state automata, learning<br>
algorithm, regular languages, prefix-closed regular languages</font></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>